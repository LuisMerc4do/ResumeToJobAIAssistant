"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n\n\n\n\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();\n    const envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangChainEnvVarsMetadata)();\n    return runs.map((run)=>{\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime\n            },\n            metadata: {\n                ...envVars,\n                ...envVars.revision_id || run.revision_id ? {\n                    revision_id: run.revision_id ?? envVars.revision_id\n                } : {},\n                ...metadata\n            }\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = ()=>{\n    const samplingRateStr = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url)=>{\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation)=>{\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable){\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"](str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nclass Client {\n    constructor(config = {}){\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"batchEndpointSupported\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRuns\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.validateApiKeyIfHosted();\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(config.callerOptions ?? {});\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs\n        };\n    }\n    validateApiKeyIfHosted() {\n        const isLocal = isLocalhost(this.apiUrl);\n        if (!isLocal && !this.apiKey) {\n            throw new Error(\"API key must be provided when using hosted LangSmith API\");\n        }\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        } else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        } else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_3__.__version__}`\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs) {\n            return {};\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs) {\n            return {};\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = {\n            ...run\n        };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while(true){\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms)\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? {\n            ...body\n        } : {};\n        while(true){\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams)\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs){\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        } else {\n            const sampled = [];\n            for (const run of runs){\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async triggerAutoBatchSend(runs) {\n        let batch = runs;\n        if (batch === undefined) {\n            batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n            this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n        }\n        await this.batchIngestRuns({\n            runCreates: batch.filter((item)=>item.action === \"create\").map((item)=>item.item),\n            runUpdates: batch.filter((item)=>item.action === \"update\").map((item)=>item.item)\n        });\n    }\n    appendRunCreateToAutoBatchQueue(item) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        this.pendingAutoBatchedRuns.push(item);\n        while(this.pendingAutoBatchedRuns.length >= this.pendingAutoBatchedRunLimit){\n            const batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n            this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n            void this.triggerAutoBatchSend(batch);\n        }\n        if (this.pendingAutoBatchedRuns.length > 0) {\n            if (!oldTimeout) {\n                this.autoBatchTimeout = setTimeout(()=>{\n                    this.autoBatchTimeout = undefined;\n                    void this.triggerAutoBatchSend();\n                }, this.autoBatchInitialDelayMs);\n            } else {\n                this.autoBatchTimeout = setTimeout(()=>{\n                    this.autoBatchTimeout = undefined;\n                    void this.triggerAutoBatchSend();\n                }, this.autoBatchAggregationDelayMs);\n            }\n        }\n    }\n    async batchEndpointIsSupported() {\n        const response = await fetch(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            // consume the response body to release the connection\n            // https://undici.nodejs.org/#/?id=garbage-collection\n            await response.text();\n            return false;\n        }\n        return true;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([\n            run\n        ]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now()\n        });\n        if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n            this.appendRunCreateToAutoBatchQueue({\n                action: \"create\",\n                item: runCreate\n            });\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async batchIngestRuns({ runCreates, runUpdates }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const body = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true)\n        };\n        if (!body.post.length && !body.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        if (this.batchEndpointSupported === undefined) {\n            this.batchEndpointSupported = await this.batchEndpointIsSupported();\n        }\n        if (!this.batchEndpointSupported) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of body.post){\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of body.patch){\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\"\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = {\n            ...run,\n            id: runId\n        };\n        if (!this._filterForSampling([\n            data\n        ], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n            this.appendRunCreateToAutoBatchQueue({\n                action: \"update\",\n                item: data\n            });\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = {\n        loadChildRuns: false\n    }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            } else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({\n                    projectName: projectOpts?.projectName\n                })).id;\n            } else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            } else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") || \"default\"\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        } else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        } else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            id: run.child_run_ids\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b)=>(a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns){\n            if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for(const runId in treemap){\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    async *listRuns({ projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, limit }) {\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [\n                projectId\n            ];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName) ? projectName : [\n                projectName\n            ];\n            const projectIds_ = await Promise.all(projectNames.map((name)=>this.readProject({\n                    projectName: name\n                }).then((project)=>project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            execution_order: executionOrder,\n            parent_run: parentRunId ? [\n                parentRunId\n            ] : null,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)){\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"]()\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds){\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = {\n                ...extra || {},\n                metadata\n            };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async hasProject({ projectId, projectName }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({\n            limit: \"1\"\n        });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)){\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds){\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)){\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        } else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId === undefined) {\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        } else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key)=>{\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key)=>{\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType } = {}) {\n        const body = {\n            name,\n            description\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({\n            limit: \"1\"\n        });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        } else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n        // do nothing\n        } else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({\n                datasetName\n            })).id;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText.trim().split(\"\\n\").map((line)=>JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)){\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx)=>{\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({\n            input\n        }, {\n            output: generation\n        }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message)=>{\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(generations) : generations;\n        return this.createExample({\n            input: finalInput\n        }, {\n            output: finalOutput\n        }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n            dataset: datasetId_\n        });\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds){\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)){\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {\n        loadChildRuns: false\n    }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, {\n                loadChildRuns\n            });\n        } else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        } else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = {\n                ...sourceInfo_,\n                ...feedbackResult.evaluatorInfo\n            };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, eager = false }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {}\n        };\n        if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = {\n                run_id: sourceRunId\n            };\n        }\n        if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source\n        };\n        const url = `${this.apiUrl}/feedback` + (eager ? \"/eager\" : \"\");\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys){\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes){\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)){\n            yield* feedbacks;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkI7QUFDeUI7QUFDc0M7QUFDaUI7QUFDcEU7QUFDekMsZUFBZVEsOEJBQThCQyxJQUFJO0lBQzdDLE1BQU1DLGFBQWEsTUFBTUosb0VBQXFCQTtJQUM5QyxNQUFNSyxVQUFVTiwwRUFBMkJBO0lBQzNDLE9BQU9JLEtBQUtHLEdBQUcsQ0FBQyxDQUFDQztRQUNiLE1BQU1DLFFBQVFELElBQUlDLEtBQUssSUFBSSxDQUFDO1FBQzVCLE1BQU1DLFdBQVdELE1BQU1DLFFBQVE7UUFDL0JGLElBQUlDLEtBQUssR0FBRztZQUNSLEdBQUdBLEtBQUs7WUFDUkUsU0FBUztnQkFDTCxHQUFHTixVQUFVO2dCQUNiLEdBQUdJLE9BQU9FLE9BQU87WUFDckI7WUFDQUQsVUFBVTtnQkFDTixHQUFHSixPQUFPO2dCQUNWLEdBQUlBLFFBQVFNLFdBQVcsSUFBSUosSUFBSUksV0FBVyxHQUNwQztvQkFBRUEsYUFBYUosSUFBSUksV0FBVyxJQUFJTixRQUFRTSxXQUFXO2dCQUFDLElBQ3RELENBQUMsQ0FBQztnQkFDUixHQUFHRixRQUFRO1lBQ2Y7UUFDSjtRQUNBLE9BQU9GO0lBQ1g7QUFDSjtBQUNBLE1BQU1LLHlCQUF5QjtJQUMzQixNQUFNQyxrQkFBa0JmLHFFQUFzQkEsQ0FBQztJQUMvQyxJQUFJZSxvQkFBb0JDLFdBQVc7UUFDL0IsT0FBT0E7SUFDWDtJQUNBLE1BQU1DLGVBQWVDLFdBQVdIO0lBQ2hDLElBQUlFLGVBQWUsS0FBS0EsZUFBZSxHQUFHO1FBQ3RDLE1BQU0sSUFBSUUsTUFBTSxDQUFDLHFFQUFxRSxFQUFFRixhQUFhLENBQUM7SUFDMUc7SUFDQSxPQUFPQTtBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCLE1BQU1HLGNBQWMsQ0FBQ0M7SUFDakIsTUFBTUMsY0FBY0QsSUFBSUUsT0FBTyxDQUFDLFdBQVcsSUFBSUEsT0FBTyxDQUFDLFlBQVk7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ZCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQmUsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxJQUFJLENBQUNsQyxTQUFTSSxFQUFFLEVBQUU7WUFDZCxNQUFNLElBQUlaLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRTZELEtBQUssRUFBRSxFQUFFckQsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU00sVUFBVSxDQUFDLENBQUM7UUFDekY7UUFDQSxNQUFNTixTQUFTZ0UsSUFBSTtJQUN2QjtJQUNBLE9BQU9xUCxhQUFhLEVBQUU3RyxNQUFNLEVBQUU4RyxZQUFZLEVBQUVDLG1CQUFtQixFQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDckUsTUFBTWpRLGNBQWMsSUFBSVk7UUFDeEIsSUFBSXNJLFFBQVE7WUFDUmxKLFlBQVltSixNQUFNLENBQUMsT0FBT0QsT0FBT2dILElBQUksQ0FBQztRQUMxQztRQUNBLElBQUlGLGNBQWM7WUFDZCxLQUFLLE1BQU1uRSxPQUFPbUUsYUFBYztnQkFDNUJoUSxZQUFZbUosTUFBTSxDQUFDLE9BQU8wQztZQUM5QjtRQUNKO1FBQ0EsSUFBSW9FLHFCQUFxQjtZQUNyQixLQUFLLE1BQU1SLFFBQVFRLG9CQUFxQjtnQkFDcENqUSxZQUFZbUosTUFBTSxDQUFDLFVBQVVzRztZQUNqQztRQUNKO1FBQ0EsV0FBVyxNQUFNVSxhQUFhLElBQUksQ0FBQ3hQLGFBQWEsQ0FBQyxhQUFhWCxhQUFjO1lBQ3hFLE9BQU9tUTtRQUNYO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3F1aWxsLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L2NsaWVudC5qcz9lZDE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSwgaXNMYW5nQ2hhaW5NZXNzYWdlLCB9IGZyb20gXCIuL3V0aWxzL21lc3NhZ2VzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCwgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IF9fdmVyc2lvbl9fIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmFzeW5jIGZ1bmN0aW9uIG1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGVzKHJ1bnMpIHtcbiAgICBjb25zdCBydW50aW1lRW52ID0gYXdhaXQgZ2V0UnVudGltZUVudmlyb25tZW50KCk7XG4gICAgY29uc3QgZW52VmFycyA9IGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSgpO1xuICAgIHJldHVybiBydW5zLm1hcCgocnVuKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gcnVuLmV4dHJhID8/IHt9O1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGV4dHJhLm1ldGFkYXRhO1xuICAgICAgICBydW4uZXh0cmEgPSB7XG4gICAgICAgICAgICAuLi5leHRyYSxcbiAgICAgICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICAgICAgICAuLi5ydW50aW1lRW52LFxuICAgICAgICAgICAgICAgIC4uLmV4dHJhPy5ydW50aW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4uZW52VmFycyxcbiAgICAgICAgICAgICAgICAuLi4oZW52VmFycy5yZXZpc2lvbl9pZCB8fCBydW4ucmV2aXNpb25faWRcbiAgICAgICAgICAgICAgICAgICAgPyB7IHJldmlzaW9uX2lkOiBydW4ucmV2aXNpb25faWQgPz8gZW52VmFycy5yZXZpc2lvbl9pZCB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9KTtcbn1cbmNvbnN0IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlU3RyID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9UUkFDSU5HX1NBTVBMSU5HX1JBVEVcIik7XG4gICAgaWYgKHNhbXBsaW5nUmF0ZVN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZSA9IHBhcnNlRmxvYXQoc2FtcGxpbmdSYXRlU3RyKTtcbiAgICBpZiAoc2FtcGxpbmdSYXRlIDwgMCB8fCBzYW1wbGluZ1JhdGUgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTEFOR0NIQUlOX1RSQUNJTkdfU0FNUExJTkdfUkFURSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSBpZiBzZXQuIEdvdDogJHtzYW1wbGluZ1JhdGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBzYW1wbGluZ1JhdGU7XG59O1xuLy8gdXRpbGl0eSBmdW5jdGlvbnNcbmNvbnN0IGlzTG9jYWxob3N0ID0gKHVybCkgPT4ge1xuICAgIGNvbnN0IHN0cmlwcGVkVXJsID0gdXJsLnJlcGxhY2UoXCJodHRwOi8vXCIsIFwiXCIpLnJlcGxhY2UoXCJodHRwczovL1wiLCBcIlwiKTtcbiAgICBjb25zdCBob3N0bmFtZSA9IHN0cmlwcGVkVXJsLnNwbGl0KFwiL1wiKVswXS5zcGxpdChcIjpcIilbMF07XG4gICAgcmV0dXJuIChob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiB8fCBob3N0bmFtZSA9PT0gXCIxMjcuMC4wLjFcIiB8fCBob3N0bmFtZSA9PT0gXCI6OjFcIik7XG59O1xuY29uc3QgcmFpc2VGb3JTdGF0dXMgPSBhc3luYyAocmVzcG9uc2UsIG9wZXJhdGlvbikgPT4ge1xuICAgIC8vIGNvbnN1bWUgdGhlIHJlc3BvbnNlIGJvZHkgdG8gcmVsZWFzZSB0aGUgY29ubmVjdGlvblxuICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvICR7b3BlcmF0aW9ufTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHtib2R5fWApO1xuICAgIH1cbn07XG5hc3luYyBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJpbVF1b3RlcyhzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9eXCIoLiopXCIkLywgXCIkMVwiKVxuICAgICAgICAucmVwbGFjZSgvXicoLiopJyQvLCBcIiQxXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VXVpZChzdHIpIHtcbiAgICBpZiAoIXV1aWQudmFsaWRhdGUoc3RyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVVJRDogJHtzdHJ9YCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpS2V5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaVVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3ZWJVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpbWVvdXRfbXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RlbmFudElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlSW5wdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpZGVPdXRwdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNpbmdTYW1wbGVSYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNhbXBsZWRQb3N0VXVpZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoVHJhY2luZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoRW5kcG9pbnRTdXBwb3J0ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGVuZGluZ0F1dG9CYXRjaGVkUnVuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBlbmRpbmdBdXRvQmF0Y2hlZFJ1bkxpbWl0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRpbWVvdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoSW5pdGlhbERlbGF5TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDI1MFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA1MFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IENsaWVudC5nZXREZWZhdWx0Q2xpZW50Q29uZmlnKCk7XG4gICAgICAgIHRoaXMudHJhY2luZ1NhbXBsZVJhdGUgPSBnZXRUcmFjaW5nU2FtcGxpbmdSYXRlKCk7XG4gICAgICAgIHRoaXMuYXBpVXJsID0gdHJpbVF1b3Rlcyhjb25maWcuYXBpVXJsID8/IGRlZmF1bHRDb25maWcuYXBpVXJsKSA/PyBcIlwiO1xuICAgICAgICB0aGlzLmFwaUtleSA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaUtleSA/PyBkZWZhdWx0Q29uZmlnLmFwaUtleSk7XG4gICAgICAgIHRoaXMud2ViVXJsID0gdHJpbVF1b3Rlcyhjb25maWcud2ViVXJsID8/IGRlZmF1bHRDb25maWcud2ViVXJsKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUFwaUtleUlmSG9zdGVkKCk7XG4gICAgICAgIHRoaXMudGltZW91dF9tcyA9IGNvbmZpZy50aW1lb3V0X21zID8/IDEyMDAwO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBBc3luY0NhbGxlcihjb25maWcuY2FsbGVyT3B0aW9ucyA/PyB7fSk7XG4gICAgICAgIHRoaXMuaGlkZUlucHV0cyA9IGNvbmZpZy5oaWRlSW5wdXRzID8/IGRlZmF1bHRDb25maWcuaGlkZUlucHV0cztcbiAgICAgICAgdGhpcy5oaWRlT3V0cHV0cyA9IGNvbmZpZy5oaWRlT3V0cHV0cyA/PyBkZWZhdWx0Q29uZmlnLmhpZGVPdXRwdXRzO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRyYWNpbmcgPSBjb25maWcuYXV0b0JhdGNoVHJhY2luZyA/PyB0aGlzLmF1dG9CYXRjaFRyYWNpbmc7XG4gICAgICAgIHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQgPVxuICAgICAgICAgICAgY29uZmlnLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bkxpbWl0ID8/IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIik7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz9cbiAgICAgICAgICAgIFwiaHR0cHM6Ly9hcGkuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICBjb25zdCBoaWRlSW5wdXRzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9ISURFX0lOUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNvbnN0IGhpZGVPdXRwdXRzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9ISURFX09VVFBVVFNcIikgPT09IFwidHJ1ZVwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpVXJsOiBhcGlVcmwsXG4gICAgICAgICAgICBhcGlLZXk6IGFwaUtleSxcbiAgICAgICAgICAgIHdlYlVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGlkZUlucHV0czogaGlkZUlucHV0cyxcbiAgICAgICAgICAgIGhpZGVPdXRwdXRzOiBoaWRlT3V0cHV0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFsaWRhdGVBcGlLZXlJZkhvc3RlZCgpIHtcbiAgICAgICAgY29uc3QgaXNMb2NhbCA9IGlzTG9jYWxob3N0KHRoaXMuYXBpVXJsKTtcbiAgICAgICAgaWYgKCFpc0xvY2FsICYmICF0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQVBJIGtleSBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gdXNpbmcgaG9zdGVkIExhbmdTbWl0aCBBUElcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SG9zdFVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMud2ViVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMb2NhbGhvc3QodGhpcy5hcGlVcmwpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cDovL2xvY2FsaG9zdFwiO1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cDovL2xvY2FsaG9zdFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLmluY2x1ZGVzKFwiL2FwaVwiKSAmJlxuICAgICAgICAgICAgIXRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5lbmRzV2l0aChcImFwaVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSB0aGlzLmFwaVVybC5yZXBsYWNlKFwiL2FwaVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJkZXZcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2Rldi5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovL2Rldi5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovL3NtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiVXNlci1BZ2VudFwiOiBgbGFuZ3NtaXRoLWpzLyR7X192ZXJzaW9uX199YCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gYCR7dGhpcy5hcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgcHJvY2Vzc0lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuICAgIHByb2Nlc3NPdXRwdXRzKG91dHB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZU91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgcHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHJ1bikge1xuICAgICAgICBjb25zdCBydW5QYXJhbXMgPSB7IC4uLnJ1biB9O1xuICAgICAgICBpZiAocnVuUGFyYW1zLmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5QYXJhbXMuaW5wdXRzID0gdGhpcy5wcm9jZXNzSW5wdXRzKHJ1blBhcmFtcy5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5QYXJhbXMub3V0cHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5QYXJhbXMub3V0cHV0cyA9IHRoaXMucHJvY2Vzc091dHB1dHMocnVuUGFyYW1zLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5QYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZXNwb25zZShwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCBwYXJhbXNTdHJpbmcgPSBxdWVyeVBhcmFtcz8udG9TdHJpbmcoKSA/PyBcIlwiO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zU3RyaW5nfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0KHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyAqX2dldFBhZ2luYXRlZChwYXRoLCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gTnVtYmVyKHF1ZXJ5UGFyYW1zLmdldChcIm9mZnNldFwiKSkgfHwgMDtcbiAgICAgICAgY29uc3QgbGltaXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwibGltaXRcIikpIHx8IDEwMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcIm9mZnNldFwiLCBTdHJpbmcob2Zmc2V0KSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoXCJsaW1pdFwiLCBTdHJpbmcobGltaXQpKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfSR7cGF0aH0/JHtxdWVyeVBhcmFtc31gO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgaXRlbXM7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKl9nZXRDdXJzb3JQYWdpbmF0ZWRMaXN0KHBhdGgsIGJvZHkgPSBudWxsLCByZXF1ZXN0TWV0aG9kID0gXCJQT1NUXCIsIGRhdGFLZXkgPSBcInJ1bnNcIikge1xuICAgICAgICBjb25zdCBib2R5UGFyYW1zID0gYm9keSA/IHsgLi4uYm9keSB9IDoge307XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfSR7cGF0aH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0TWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHlQYXJhbXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHlbZGF0YUtleV0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHJlc3BvbnNlQm9keVtkYXRhS2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvcnMgPSByZXNwb25zZUJvZHkuY3Vyc29ycztcbiAgICAgICAgICAgIGlmICghY3Vyc29ycykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJzb3JzLm5leHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHlQYXJhbXMuY3Vyc29yID0gY3Vyc29ycy5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9maWx0ZXJGb3JTYW1wbGluZyhydW5zLCBwYXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBydW5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNhbXBsZWRQb3N0VXVpZHMuaGFzKHJ1bi5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlZFBvc3RVdWlkcy5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHRoaXMudHJhY2luZ1NhbXBsZVJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlZFBvc3RVdWlkcy5hZGQocnVuLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0cmlnZ2VyQXV0b0JhdGNoU2VuZChydW5zKSB7XG4gICAgICAgIGxldCBiYXRjaCA9IHJ1bnM7XG4gICAgICAgIGlmIChiYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiYXRjaCA9IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVucy5zbGljZSgwLCB0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bkxpbWl0KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVucyA9IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVucy5zbGljZSh0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bkxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0UnVucyh7XG4gICAgICAgICAgICBydW5DcmVhdGVzOiBiYXRjaFxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICBydW5VcGRhdGVzOiBiYXRjaFxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcInVwZGF0ZVwiKVxuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBlbmRSdW5DcmVhdGVUb0F1dG9CYXRjaFF1ZXVlKGl0ZW0pIHtcbiAgICAgICAgY29uc3Qgb2xkVGltZW91dCA9IHRoaXMuYXV0b0JhdGNoVGltZW91dDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b0JhdGNoVGltZW91dCk7XG4gICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5zLnB1c2goaXRlbSk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bnMubGVuZ3RoID49IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5zLnNsaWNlKDAsIHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5zID0gdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5zLnNsaWNlKHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQpO1xuICAgICAgICAgICAgdm9pZCB0aGlzLnRyaWdnZXJBdXRvQmF0Y2hTZW5kKGJhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghb2xkVGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy50cmlnZ2VyQXV0b0JhdGNoU2VuZCgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuYXV0b0JhdGNoSW5pdGlhbERlbGF5TXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnRyaWdnZXJBdXRvQmF0Y2hTZW5kKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5hdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoRW5kcG9pbnRJc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmFwaVVybH0vaW5mb2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgICAgICBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVJ1bihydW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhbcnVuXSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICAgICAgICBjb25zdCBzZXNzaW9uX25hbWUgPSBydW4ucHJvamVjdF9uYW1lO1xuICAgICAgICBkZWxldGUgcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgY29uc3QgcnVuQ3JlYXRlID0gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoe1xuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lLFxuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUgPz8gRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFRyYWNpbmcgJiZcbiAgICAgICAgICAgIHJ1bkNyZWF0ZS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBydW5DcmVhdGUuZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kUnVuQ3JlYXRlVG9BdXRvQmF0Y2hRdWV1ZSh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgIGl0ZW06IHJ1bkNyZWF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlZFJ1bkNyZWF0ZVBhcmFtcyA9IGF3YWl0IG1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGVzKFtcbiAgICAgICAgICAgIHJ1bkNyZWF0ZSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3J1bnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1lcmdlZFJ1bkNyZWF0ZVBhcmFtc1swXSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBydW5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhdGNoIGluZ2VzdC91cHNlcnQgbXVsdGlwbGUgcnVucyBpbiB0aGUgTGFuZ3NtaXRoIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gcnVuc1xuICAgICAqL1xuICAgIGFzeW5jIGJhdGNoSW5nZXN0UnVucyh7IHJ1bkNyZWF0ZXMsIHJ1blVwZGF0ZXMsIH0pIHtcbiAgICAgICAgaWYgKHJ1bkNyZWF0ZXMgPT09IHVuZGVmaW5lZCAmJiBydW5VcGRhdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBydW5DcmVhdGVzPy5tYXAoKGNyZWF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoY3JlYXRlKSkgPz8gW107XG4gICAgICAgIGxldCBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHJ1blVwZGF0ZXM/Lm1hcCgodXBkYXRlKSA9PiB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh1cGRhdGUpKSA/PyBbXTtcbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA+IDAgJiYgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQnlJZCA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLnJlZHVjZSgocGFyYW1zLCBydW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbcnVuLmlkXSA9IHJ1bjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhbG9uZVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlUGFyYW0gb2YgcHJlcGFyZWRVcGRhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCAmJiBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlUGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lVXBkYXRlcy5wdXNoKHVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IE9iamVjdC52YWx1ZXMoY3JlYXRlQnlJZCk7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHN0YW5kYWxvbmVVcGRhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBwb3N0OiB0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhwcmVwYXJlZENyZWF0ZVBhcmFtcyksXG4gICAgICAgICAgICBwYXRjaDogdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcocHJlcGFyZWRVcGRhdGVQYXJhbXMsIHRydWUpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWJvZHkucG9zdC5sZW5ndGggJiYgIWJvZHkucGF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBhd2FpdCBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlcyhwcmVwYXJlZENyZWF0ZVBhcmFtcyk7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoRW5kcG9pbnRTdXBwb3J0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5iYXRjaEVuZHBvaW50U3VwcG9ydGVkID0gYXdhaXQgdGhpcy5iYXRjaEVuZHBvaW50SXNTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmF0Y2hFbmRwb2ludFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUcmFjaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZXBhcmVkQ3JlYXRlUGFyYW0gb2YgYm9keS5wb3N0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVSdW4ocHJlcGFyZWRDcmVhdGVQYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZXBhcmVkVXBkYXRlUGFyYW0gb2YgYm9keS5wYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVwYXJlZFVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVSdW4ocHJlcGFyZWRVcGRhdGVQYXJhbS5pZCwgcHJlcGFyZWRVcGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvYmF0Y2hgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJiYXRjaCBjcmVhdGUgcnVuXCIpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVSdW4ocnVuSWQsIHJ1bikge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgaWYgKHJ1bi5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSB0aGlzLnByb2Nlc3NJbnB1dHMocnVuLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bi5vdXRwdXRzKSB7XG4gICAgICAgICAgICBydW4ub3V0cHV0cyA9IHRoaXMucHJvY2Vzc091dHB1dHMocnVuLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFVudGFuZ2xlIHR5cGVzXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IC4uLnJ1biwgaWQ6IHJ1bklkIH07XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW2RhdGFdLCB0cnVlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBkYXRhLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGRhdGEuZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kUnVuQ3JlYXRlVG9BdXRvQmF0Y2hRdWV1ZSh7IGFjdGlvbjogXCJ1cGRhdGVcIiwgaXRlbTogZGF0YSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShydW4pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgcnVuXCIpO1xuICAgIH1cbiAgICBhc3luYyByZWFkUnVuKHJ1bklkLCB7IGxvYWRDaGlsZFJ1bnMgfSA9IHsgbG9hZENoaWxkUnVuczogZmFsc2UgfSkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgbGV0IHJ1biA9IGF3YWl0IHRoaXMuX2dldChgL3J1bnMvJHtydW5JZH1gKTtcbiAgICAgICAgaWYgKGxvYWRDaGlsZFJ1bnMgJiYgcnVuLmNoaWxkX3J1bl9pZHMpIHtcbiAgICAgICAgICAgIHJ1biA9IGF3YWl0IHRoaXMuX2xvYWRDaGlsZFJ1bnMocnVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBnZXRSdW5VcmwoeyBydW5JZCwgcnVuLCBwcm9qZWN0T3B0cywgfSkge1xuICAgICAgICBpZiAocnVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uSWQ7XG4gICAgICAgICAgICBpZiAocnVuLnNlc3Npb25faWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBydW4uc2Vzc2lvbl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IHByb2plY3RPcHRzPy5wcm9qZWN0TmFtZSB9KSkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9qZWN0T3B0cz8ucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcHJvamVjdE9wdHM/LnByb2plY3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2plY3QgPSBhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5hbWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fUFJPSkVDVFwiKSB8fCBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L3Byb2plY3RzL3AvJHtzZXNzaW9uSWR9L3IvJHtydW4uaWR9P3BvbGw9dHJ1ZWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcnVuXyA9IGF3YWl0IHRoaXMucmVhZFJ1bihydW5JZCk7XG4gICAgICAgICAgICBpZiAoIXJ1bl8uYXBwX3BhdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1biAke3J1bklkfSBoYXMgbm8gYXBwX3BhdGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEhvc3RVcmwoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtiYXNlVXJsfSR7cnVuXy5hcHBfcGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBydW5JZCBvciBydW5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xvYWRDaGlsZFJ1bnMocnVuKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUnVucyA9IGF3YWl0IHRvQXJyYXkodGhpcy5saXN0UnVucyh7IGlkOiBydW4uY2hpbGRfcnVuX2lkcyB9KSk7XG4gICAgICAgIGNvbnN0IHRyZWVtYXAgPSB7fTtcbiAgICAgICAgY29uc3QgcnVucyA9IHt9O1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGRvdHRlZCBvcmRlciByZXF1aXJlZCB3aGVuIHRoZSBtaWdyYXRpb24gZmluaXNoZXNcbiAgICAgICAgY2hpbGRSdW5zLnNvcnQoKGEsIGIpID0+IChhPy5kb3R0ZWRfb3JkZXIgPz8gXCJcIikubG9jYWxlQ29tcGFyZShiPy5kb3R0ZWRfb3JkZXIgPz8gXCJcIikpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkUnVuIG9mIGNoaWxkUnVucykge1xuICAgICAgICAgICAgaWYgKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHJ1biAke2NoaWxkUnVuLmlkfSBoYXMgbm8gcGFyZW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkIGluIHRyZWVtYXApKSB7XG4gICAgICAgICAgICAgICAgdHJlZW1hcFtjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJlZW1hcFtjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkXS5wdXNoKGNoaWxkUnVuKTtcbiAgICAgICAgICAgIHJ1bnNbY2hpbGRSdW4uaWRdID0gY2hpbGRSdW47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bi5pZF0gfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgcnVuSWQgaW4gdHJlZW1hcCkge1xuICAgICAgICAgICAgaWYgKHJ1bklkICE9PSBydW4uaWQpIHtcbiAgICAgICAgICAgICAgICBydW5zW3J1bklkXS5jaGlsZF9ydW5zID0gdHJlZW1hcFtydW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RSdW5zKHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgcGFyZW50UnVuSWQsIHRyYWNlSWQsIHJlZmVyZW5jZUV4YW1wbGVJZCwgc3RhcnRUaW1lLCBleGVjdXRpb25PcmRlciwgcnVuVHlwZSwgZXJyb3IsIGlkLCBxdWVyeSwgZmlsdGVyLCBsaW1pdCwgfSkge1xuICAgICAgICBsZXQgcHJvamVjdElkcyA9IFtdO1xuICAgICAgICBpZiAocHJvamVjdElkKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWRzID0gQXJyYXkuaXNBcnJheShwcm9qZWN0SWQpID8gcHJvamVjdElkIDogW3Byb2plY3RJZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0TmFtZXMgPSBBcnJheS5pc0FycmF5KHByb2plY3ROYW1lKVxuICAgICAgICAgICAgICAgID8gcHJvamVjdE5hbWVcbiAgICAgICAgICAgICAgICA6IFtwcm9qZWN0TmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0SWRzXyA9IGF3YWl0IFByb21pc2UuYWxsKHByb2plY3ROYW1lcy5tYXAoKG5hbWUpID0+IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogbmFtZSB9KS50aGVuKChwcm9qZWN0KSA9PiBwcm9qZWN0LmlkKSkpO1xuICAgICAgICAgICAgcHJvamVjdElkcy5wdXNoKC4uLnByb2plY3RJZHNfKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgc2Vzc2lvbjogcHJvamVjdElkcy5sZW5ndGggPyBwcm9qZWN0SWRzIDogbnVsbCxcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGU6IHJlZmVyZW5jZUV4YW1wbGVJZCxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25PcmRlcixcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHBhcmVudFJ1bklkID8gW3BhcmVudFJ1bklkXSA6IG51bGwsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB0cmFjZTogdHJhY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldEN1cnNvclBhZ2luYXRlZExpc3QoXCIvcnVucy9xdWVyeVwiLCBib2R5KSkge1xuICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2hhcmVSdW4ocnVuSWQsIHsgc2hhcmVJZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlUnVuKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyBsaXN0U2hhcmVkUnVucyhzaGFyZVRva2VuLCB7IHJ1bklkcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydW5JZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW5JZCBvZiBydW5JZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJpZFwiLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcnVucztcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRTaGFyZWRTY2hlbWEoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlRGF0YXNldChkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlRGF0YXNldChkYXRhc2V0SWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVuc2hhcmUgZGF0YXNldFwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFNoYXJlZERhdGFzZXQoc2hhcmVUb2tlbikge1xuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb2plY3QoeyBwcm9qZWN0TmFtZSwgZGVzY3JpcHRpb24gPSBudWxsLCBtZXRhZGF0YSA9IG51bGwsIHVwc2VydCA9IGZhbHNlLCBwcm9qZWN0RXh0cmEgPSBudWxsLCByZWZlcmVuY2VEYXRhc2V0SWQgPSBudWxsLCB9KSB7XG4gICAgICAgIGNvbnN0IHVwc2VydF8gPSB1cHNlcnQgPyBgP3Vwc2VydD10cnVlYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zJHt1cHNlcnRffWA7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gcHJvamVjdEV4dHJhIHx8IHt9O1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBib2R5W1wicmVmZXJlbmNlX2RhdGFzZXRfaWRcIl0gPSByZWZlcmVuY2VEYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb24gJHtwcm9qZWN0TmFtZX06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHsgbmFtZSA9IG51bGwsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCBwcm9qZWN0RXh0cmEgPSBudWxsLCBlbmRUaW1lID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZH1gO1xuICAgICAgICBsZXQgZXh0cmEgPSBwcm9qZWN0RXh0cmE7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmEgPSB7IC4uLihleHRyYSB8fCB7fSksIG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUgPyBuZXcgRGF0ZShlbmRUaW1lKS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBwcm9qZWN0ICR7cHJvamVjdElkfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBoYXNQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICAvLyBUT0RPOiBBZGQgYSBoZWFkIHJlcXVlc3RcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBPSyBhbmQgd2UncmUgcXVlcnlpbmcgYnkgbmFtZSwgbmVlZCB0byBjaGVjayB0aGUgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9qZWN0SWQgcXVlcnlpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBpbmNsdWRlU3RhdHMsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWN0W2lkPSR7cHJvamVjdElkfSwgbmFtZT0ke3Byb2plY3ROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRUZW5hbnRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbmFudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudElkID0gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9qZWN0cyBmb3VuZCB0byByZXNvbHZlIHRlbmFudC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvamVjdHMoeyBwcm9qZWN0SWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIHJlZmVyZW5jZURhdGFzZXRJZCwgcmVmZXJlbmNlRGF0YXNldE5hbWUsIHJlZmVyZW5jZUZyZWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvamVjdElkIG9mIHByb2plY3RJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgcHJvamVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgcmVmZXJlbmNlRGF0YXNldElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWZlcmVuY2VEYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7XG4gICAgICAgICAgICAgICAgZGF0YXNldE5hbWU6IHJlZmVyZW5jZURhdGFzZXROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgZGF0YXNldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZUZyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9mcmVlXCIsIHJlZmVyZW5jZUZyZWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb2plY3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfO1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWRfKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWRffWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgc2Vzc2lvbiAke3Byb2plY3RJZF99ICgke3Byb2plY3ROYW1lfSlgKTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkQ3N2KHsgY3N2RmlsZSwgZmlsZU5hbWUsIGlucHV0S2V5cywgb3V0cHV0S2V5cywgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBuYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy91cGxvYWRgO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGNzdkZpbGUsIGZpbGVOYW1lKTtcbiAgICAgICAgaW5wdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm91dHB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRhdGFfdHlwZVwiLCBkYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZXRhaWwgJiYgcmVzdWx0LmRldGFpbC5pbmNsdWRlcyhcImFscmVhZHkgZXhpc3RzXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0ICR7ZmlsZU5hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgQ1NWOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGF0YXNldChuYW1lLCB7IGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgYm9keS5kYXRhX3R5cGUgPSBkYXRhVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRldGFpbCAmJiByZXN1bHQuZGV0YWlsLmluY2x1ZGVzKFwiYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXQgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGRhdGFzZXQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIC8vIGxpbWl0IHRvIDEgcmVzdWx0XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKGAke3BhdGh9LyR7ZGF0YXNldElkfS9vcGVuYWlfZnRgKTtcbiAgICAgICAgY29uc3QgZGF0YXNldFRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0VGV4dFxuICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAubWFwKChsaW5lKSA9PiBKU09OLnBhcnNlKGxpbmUpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RGF0YXNldHMoeyBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCwgZGF0YXNldElkcywgZGF0YXNldE5hbWUsIGRhdGFzZXROYW1lQ29udGFpbnMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YXNldElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBkYXRhc2V0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBkYXRhc2V0TmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGFzZXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChwYXRoLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZGF0YXNldHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZF99YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlKGlucHV0cywgb3V0cHV0cywgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBjcmVhdGVkQXQsIGV4YW1wbGVJZCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZEF0XyA9IGNyZWF0ZWRBdCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkXyxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBjcmVhdGVkQXRfPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgaWQ6IGV4YW1wbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGV4YW1wbGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlcyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgc291cmNlUnVuSWRzLCBleGFtcGxlSWRzLCBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRXhhbXBsZXMgPSBpbnB1dHMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZF8sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzID8gb3V0cHV0c1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGlkOiBleGFtcGxlSWRzID8gZXhhbXBsZUlkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IHNvdXJjZVJ1bklkcyA/IHNvdXJjZVJ1bklkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzL2J1bGtgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmb3JtYXR0ZWRFeGFtcGxlcyksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBleGFtcGxlczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUxMTUV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0IH0sIHsgb3V0cHV0OiBnZW5lcmF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDaGF0RXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxJbnB1dCA9IGlucHV0Lm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmluYWxPdXRwdXQgPSBpc0xhbmdDaGFpbk1lc3NhZ2UoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA/IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0OiBmaW5hbElucHV0IH0sIHsgb3V0cHV0OiBmaW5hbE91dHB1dCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RFeGFtcGxlcyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGV4YW1wbGVJZHMsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGRhdGFzZXQ6IGRhdGFzZXRJZF8gfSk7XG4gICAgICAgIGlmIChleGFtcGxlSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGV4YW1wbGVJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV4YW1wbGVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9leGFtcGxlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGUoZXhhbXBsZUlkLCB1cGRhdGUpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9leGFtcGxlcy8ke2V4YW1wbGVJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIGV4YW1wbGUgJHtleGFtcGxlSWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGVSdW4ocnVuLCBldmFsdWF0b3IsIHsgc291cmNlSW5mbywgbG9hZENoaWxkUnVucywgcmVmZXJlbmNlRXhhbXBsZSwgfSA9IHsgbG9hZENoaWxkUnVuczogZmFsc2UgfSkge1xuICAgICAgICBsZXQgcnVuXztcbiAgICAgICAgaWYgKHR5cGVvZiBydW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuLCB7IGxvYWRDaGlsZFJ1bnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1biA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcnVuKSB7XG4gICAgICAgICAgICBydW5fID0gcnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJ1biB0eXBlOiAke3R5cGVvZiBydW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tSZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVSdW4ocnVuXywgcmVmZXJlbmNlRXhhbXBsZSk7XG4gICAgICAgIGxldCBzb3VyY2VJbmZvXyA9IHNvdXJjZUluZm8gPz8ge307XG4gICAgICAgIGlmIChmZWVkYmFja1Jlc3VsdC5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICBzb3VyY2VJbmZvXyA9IHsgLi4uc291cmNlSW5mb18sIC4uLmZlZWRiYWNrUmVzdWx0LmV2YWx1YXRvckluZm8gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JZCA9IGZlZWRiYWNrUmVzdWx0LnRhcmdldFJ1bklkID8/IHJ1bl8uaWQ7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUZlZWRiYWNrKHJ1bklkLCBmZWVkYmFja1Jlc3VsdC5rZXksIHtcbiAgICAgICAgICAgIHNjb3JlOiBmZWVkYmFja1Jlc3VsdD8uc2NvcmUsXG4gICAgICAgICAgICB2YWx1ZTogZmVlZGJhY2tSZXN1bHQ/LnZhbHVlLFxuICAgICAgICAgICAgY29tbWVudDogZmVlZGJhY2tSZXN1bHQ/LmNvbW1lbnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiBmZWVkYmFja1Jlc3VsdD8uY29ycmVjdGlvbixcbiAgICAgICAgICAgIHNvdXJjZUluZm86IHNvdXJjZUluZm9fLFxuICAgICAgICAgICAgZmVlZGJhY2tTb3VyY2VUeXBlOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICBzb3VyY2VSdW5JZDogZmVlZGJhY2tSZXN1bHQ/LnNvdXJjZVJ1bklkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRmVlZGJhY2socnVuSWQsIGtleSwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIHNvdXJjZUluZm8sIGZlZWRiYWNrU291cmNlVHlwZSA9IFwiYXBpXCIsIHNvdXJjZVJ1bklkLCBmZWVkYmFja0lkLCBlYWdlciA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrX3NvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGZlZWRiYWNrU291cmNlVHlwZSA/PyBcImFwaVwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHNvdXJjZUluZm8gPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzb3VyY2VSdW5JZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSkge1xuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0gPSB7IHJ1bl9pZDogc291cmNlUnVuSWQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXT8ucnVuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0ucnVuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgIGlkOiBmZWVkYmFja0lkID8/IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY29ycmVjdGlvbixcbiAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U6IGZlZWRiYWNrX3NvdXJjZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrYCArIChlYWdlciA/IFwiL2VhZ2VyXCIgOiBcIlwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGZlZWRiYWNrXCIpO1xuICAgICAgICByZXR1cm4gZmVlZGJhY2s7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUZlZWRiYWNrKGZlZWRiYWNrSWQsIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXBkYXRlID0ge307XG4gICAgICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIHNjb3JlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcInNjb3JlXCJdID0gc2NvcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ycmVjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvcnJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29ycmVjdGlvblwiXSA9IGNvcnJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCAmJiBjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvbW1lbnRcIl0gPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2tVcGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZmVlZGJhY2tcIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RmVlZGJhY2soeyBydW5JZHMsIGZlZWRiYWNrS2V5cywgZmVlZGJhY2tTb3VyY2VUeXBlcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocnVuSWRzKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJydW5cIiwgcnVuSWRzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzb3VyY2VcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBmZWVkYmFja3Mgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGZlZWRiYWNrcztcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJ1dWlkIiwiQXN5bmNDYWxsZXIiLCJjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSIsImlzTGFuZ0NoYWluTWVzc2FnZSIsImdldEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEiLCJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCJfX3ZlcnNpb25fXyIsIm1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGVzIiwicnVucyIsInJ1bnRpbWVFbnYiLCJlbnZWYXJzIiwibWFwIiwicnVuIiwiZXh0cmEiLCJtZXRhZGF0YSIsInJ1bnRpbWUiLCJyZXZpc2lvbl9pZCIsImdldFRyYWNpbmdTYW1wbGluZ1JhdGUiLCJzYW1wbGluZ1JhdGVTdHIiLCJ1bmRlZmluZWQiLCJzYW1wbGluZ1JhdGUiLCJwYXJzZUZsb2F0IiwiRXJyb3IiLCJpc0xvY2FsaG9zdCIsInVybCIsInN0cmlwcGVkVXJsIiwicmVwbGFjZSIsImhvc3RuYW1lIiwic3BsaXQiLCJyYWlzZUZvclN0YXR1cyIsInJlc3BvbnNlIiwib3BlcmF0aW9uIiwiYm9keSIsInRleHQiLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJ0b0FycmF5IiwiaXRlcmFibGUiLCJyZXN1bHQiLCJpdGVtIiwicHVzaCIsInRyaW1RdW90ZXMiLCJzdHIiLCJ0cmltIiwiYXNzZXJ0VXVpZCIsInZhbGlkYXRlIiwiQ2xpZW50IiwiY29uc3RydWN0b3IiLCJjb25maWciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiU2V0IiwiZGVmYXVsdENvbmZpZyIsImdldERlZmF1bHRDbGllbnRDb25maWciLCJ0cmFjaW5nU2FtcGxlUmF0ZSIsImFwaVVybCIsImFwaUtleSIsIndlYlVybCIsInZhbGlkYXRlQXBpS2V5SWZIb3N0ZWQiLCJ0aW1lb3V0X21zIiwiY2FsbGVyIiwiY2FsbGVyT3B0aW9ucyIsImhpZGVJbnB1dHMiLCJoaWRlT3V0cHV0cyIsImF1dG9CYXRjaFRyYWNpbmciLCJwZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCIsImlzTG9jYWwiLCJnZXRIb3N0VXJsIiwiaW5jbHVkZXMiLCJlbmRzV2l0aCIsImhlYWRlcnMiLCJwcm9jZXNzSW5wdXRzIiwiaW5wdXRzIiwicHJvY2Vzc091dHB1dHMiLCJvdXRwdXRzIiwicHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzIiwicnVuUGFyYW1zIiwiX2dldFJlc3BvbnNlIiwicGF0aCIsInF1ZXJ5UGFyYW1zIiwicGFyYW1zU3RyaW5nIiwidG9TdHJpbmciLCJjYWxsIiwiZmV0Y2giLCJtZXRob2QiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJfZ2V0IiwianNvbiIsIl9nZXRQYWdpbmF0ZWQiLCJVUkxTZWFyY2hQYXJhbXMiLCJvZmZzZXQiLCJOdW1iZXIiLCJnZXQiLCJsaW1pdCIsInNldCIsIlN0cmluZyIsIml0ZW1zIiwibGVuZ3RoIiwiX2dldEN1cnNvclBhZ2luYXRlZExpc3QiLCJyZXF1ZXN0TWV0aG9kIiwiZGF0YUtleSIsImJvZHlQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2VCb2R5IiwiY3Vyc29ycyIsIm5leHQiLCJjdXJzb3IiLCJfZmlsdGVyRm9yU2FtcGxpbmciLCJwYXRjaCIsInNhbXBsZWQiLCJzYW1wbGVkUG9zdFV1aWRzIiwiaGFzIiwiaWQiLCJkZWxldGUiLCJNYXRoIiwicmFuZG9tIiwiYWRkIiwidHJpZ2dlckF1dG9CYXRjaFNlbmQiLCJiYXRjaCIsInBlbmRpbmdBdXRvQmF0Y2hlZFJ1bnMiLCJzbGljZSIsImJhdGNoSW5nZXN0UnVucyIsInJ1bkNyZWF0ZXMiLCJmaWx0ZXIiLCJhY3Rpb24iLCJydW5VcGRhdGVzIiwiYXBwZW5kUnVuQ3JlYXRlVG9BdXRvQmF0Y2hRdWV1ZSIsIm9sZFRpbWVvdXQiLCJhdXRvQmF0Y2hUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImF1dG9CYXRjaEluaXRpYWxEZWxheU1zIiwiYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zIiwiYmF0Y2hFbmRwb2ludElzU3VwcG9ydGVkIiwiQWNjZXB0IiwiY3JlYXRlUnVuIiwic2Vzc2lvbl9uYW1lIiwicHJvamVjdF9uYW1lIiwicnVuQ3JlYXRlIiwic3RhcnRfdGltZSIsIkRhdGUiLCJub3ciLCJ0cmFjZV9pZCIsImRvdHRlZF9vcmRlciIsIm1lcmdlZFJ1bkNyZWF0ZVBhcmFtcyIsInByZXBhcmVkQ3JlYXRlUGFyYW1zIiwiY3JlYXRlIiwicHJlcGFyZWRVcGRhdGVQYXJhbXMiLCJ1cGRhdGUiLCJjcmVhdGVCeUlkIiwicmVkdWNlIiwicGFyYW1zIiwic3RhbmRhbG9uZVVwZGF0ZXMiLCJ1cGRhdGVQYXJhbSIsInZhbHVlcyIsInBvc3QiLCJiYXRjaEVuZHBvaW50U3VwcG9ydGVkIiwicHJlcGFyZWRDcmVhdGVQYXJhbSIsInByZXBhcmVkVXBkYXRlUGFyYW0iLCJ1cGRhdGVSdW4iLCJydW5JZCIsImRhdGEiLCJyZWFkUnVuIiwibG9hZENoaWxkUnVucyIsImNoaWxkX3J1bl9pZHMiLCJfbG9hZENoaWxkUnVucyIsImdldFJ1blVybCIsInByb2plY3RPcHRzIiwic2Vzc2lvbklkIiwic2Vzc2lvbl9pZCIsInByb2plY3ROYW1lIiwicmVhZFByb2plY3QiLCJwcm9qZWN0SWQiLCJwcm9qZWN0IiwidGVuYW50SWQiLCJfZ2V0VGVuYW50SWQiLCJydW5fIiwiYXBwX3BhdGgiLCJiYXNlVXJsIiwiY2hpbGRSdW5zIiwibGlzdFJ1bnMiLCJ0cmVlbWFwIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImNoaWxkUnVuIiwicGFyZW50X3J1bl9pZCIsImNoaWxkX3J1bnMiLCJwYXJlbnRSdW5JZCIsInRyYWNlSWQiLCJyZWZlcmVuY2VFeGFtcGxlSWQiLCJzdGFydFRpbWUiLCJleGVjdXRpb25PcmRlciIsInJ1blR5cGUiLCJlcnJvciIsInF1ZXJ5IiwicHJvamVjdElkcyIsIkFycmF5IiwiaXNBcnJheSIsInByb2plY3ROYW1lcyIsInByb2plY3RJZHNfIiwiUHJvbWlzZSIsImFsbCIsIm5hbWUiLCJ0aGVuIiwic2Vzc2lvbiIsInJ1bl90eXBlIiwicmVmZXJlbmNlX2V4YW1wbGUiLCJleGVjdXRpb25fb3JkZXIiLCJwYXJlbnRfcnVuIiwidG9JU09TdHJpbmciLCJ0cmFjZSIsInNoYXJlUnVuIiwic2hhcmVJZCIsInJ1bl9pZCIsInNoYXJlX3Rva2VuIiwidjQiLCJ1bnNoYXJlUnVuIiwicmVhZFJ1blNoYXJlZExpbmsiLCJsaXN0U2hhcmVkUnVucyIsInNoYXJlVG9rZW4iLCJydW5JZHMiLCJhcHBlbmQiLCJyZWFkRGF0YXNldFNoYXJlZFNjaGVtYSIsImRhdGFzZXRJZCIsImRhdGFzZXROYW1lIiwiZGF0YXNldCIsInJlYWREYXRhc2V0Iiwic2hhcmVTY2hlbWEiLCJzaGFyZURhdGFzZXQiLCJkYXRhc2V0X2lkIiwidW5zaGFyZURhdGFzZXQiLCJyZWFkU2hhcmVkRGF0YXNldCIsImNyZWF0ZVByb2plY3QiLCJkZXNjcmlwdGlvbiIsInVwc2VydCIsInByb2plY3RFeHRyYSIsInJlZmVyZW5jZURhdGFzZXRJZCIsInVwc2VydF8iLCJlbmRwb2ludCIsInVwZGF0ZVByb2plY3QiLCJlbmRUaW1lIiwiZW5kX3RpbWUiLCJoYXNQcm9qZWN0IiwiZSIsImluY2x1ZGVTdGF0cyIsIl90ZW5hbnRJZCIsInByb2plY3RzIiwidGVuYW50X2lkIiwibGlzdFByb2plY3RzIiwibmFtZUNvbnRhaW5zIiwicmVmZXJlbmNlRGF0YXNldE5hbWUiLCJyZWZlcmVuY2VGcmVlIiwiZGVsZXRlUHJvamVjdCIsInByb2plY3RJZF8iLCJ1cGxvYWRDc3YiLCJjc3ZGaWxlIiwiZmlsZU5hbWUiLCJpbnB1dEtleXMiLCJvdXRwdXRLZXlzIiwiZGF0YVR5cGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZm9yRWFjaCIsImtleSIsImRldGFpbCIsImNyZWF0ZURhdGFzZXQiLCJkYXRhX3R5cGUiLCJyZWFkRGF0YXNldE9wZW5haUZpbmV0dW5pbmciLCJkYXRhc2V0VGV4dCIsImxpbmUiLCJwYXJzZSIsImxpc3REYXRhc2V0cyIsImRhdGFzZXRJZHMiLCJkYXRhc2V0TmFtZUNvbnRhaW5zIiwiaWRfIiwiZGF0YXNldHMiLCJkZWxldGVEYXRhc2V0IiwiZGF0YXNldElkXyIsImNyZWF0ZUV4YW1wbGUiLCJjcmVhdGVkQXQiLCJleGFtcGxlSWQiLCJjcmVhdGVkQXRfIiwiY3JlYXRlZF9hdCIsImNyZWF0ZUV4YW1wbGVzIiwicHJvcHMiLCJzb3VyY2VSdW5JZHMiLCJleGFtcGxlSWRzIiwiZm9ybWF0dGVkRXhhbXBsZXMiLCJpbnB1dCIsImlkeCIsInNvdXJjZV9ydW5faWQiLCJjcmVhdGVMTE1FeGFtcGxlIiwiZ2VuZXJhdGlvbiIsIm9wdGlvbnMiLCJvdXRwdXQiLCJjcmVhdGVDaGF0RXhhbXBsZSIsImdlbmVyYXRpb25zIiwiZmluYWxJbnB1dCIsIm1lc3NhZ2UiLCJmaW5hbE91dHB1dCIsInJlYWRFeGFtcGxlIiwibGlzdEV4YW1wbGVzIiwiZXhhbXBsZXMiLCJkZWxldGVFeGFtcGxlIiwidXBkYXRlRXhhbXBsZSIsImV2YWx1YXRlUnVuIiwiZXZhbHVhdG9yIiwic291cmNlSW5mbyIsInJlZmVyZW5jZUV4YW1wbGUiLCJyZWZlcmVuY2VfZXhhbXBsZV9pZCIsImZlZWRiYWNrUmVzdWx0Iiwic291cmNlSW5mb18iLCJldmFsdWF0b3JJbmZvIiwidGFyZ2V0UnVuSWQiLCJjcmVhdGVGZWVkYmFjayIsInNjb3JlIiwiY29tbWVudCIsImNvcnJlY3Rpb24iLCJmZWVkYmFja1NvdXJjZVR5cGUiLCJzb3VyY2VSdW5JZCIsImZlZWRiYWNrSWQiLCJlYWdlciIsImZlZWRiYWNrX3NvdXJjZSIsInR5cGUiLCJmZWVkYmFjayIsInVwZGF0ZUZlZWRiYWNrIiwiZmVlZGJhY2tVcGRhdGUiLCJyZWFkRmVlZGJhY2siLCJkZWxldGVGZWVkYmFjayIsImxpc3RGZWVkYmFjayIsImZlZWRiYWNrS2V5cyIsImZlZWRiYWNrU291cmNlVHlwZXMiLCJqb2luIiwiZmVlZGJhY2tzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.0.70\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUM7QUFDSTtBQUN6QyxpQ0FBaUM7QUFDMUIsTUFBTUUsY0FBYyxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVpbGwvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanM/YWEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmV4cG9ydCB7IFJ1blRyZWUgfSBmcm9tIFwiLi9ydW5fdHJlZXMuanNcIjtcbi8vIFVwZGF0ZSB1c2luZyB5YXJuIGJ1bXAtdmVyc2lvblxuZXhwb3J0IGNvbnN0IF9fdmVyc2lvbl9fID0gXCIwLjAuNzBcIjtcbiJdLCJuYW1lcyI6WyJDbGllbnQiLCJSdW5UcmVlIiwiX192ZXJzaW9uX18iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n\n\n\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId) {\n    return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}000Z`) + runId;\n}\nclass RunTree {\n    constructor(config){\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = RunTree.getDefaultConfig();\n        Object.assign(this, {\n            ...defaultConfig,\n            ...config\n        });\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id;\n            } else {\n                this.trace_id = this.id;\n            }\n        }\n        if (!this.dotted_order) {\n            const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + currentDottedOrder;\n            } else {\n                this.dotted_order = currentDottedOrder;\n            }\n        }\n    }\n    static getDefaultConfig() {\n        return {\n            id: uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"](),\n            run_type: \"chain\",\n            project_name: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n            \"default\",\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time: Date.now(),\n            serialized: {},\n            inputs: {},\n            extra: {},\n            client: new _client_js__WEBPACK_IMPORTED_MODULE_1__.Client({})\n        };\n    }\n    async createChild(config) {\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            client: this.client\n        });\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now()) {\n        this.outputs = outputs;\n        this.error = error;\n        this.end_time = endTime;\n    }\n    async _convertToCreate(run, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        if (!runExtra.runtime) {\n            runExtra.runtime = {};\n        }\n        const runtimeEnv = await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment)();\n        for (const [k, v] of Object.entries(runtimeEnv)){\n            if (!runExtra.runtime[k]) {\n                runExtra.runtime[k] = v;\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = await Promise.all(run.child_runs.map((child_run)=>this._convertToCreate(child_run, excludeChildRuns)));\n            parent_run_id = undefined;\n        } else {\n            parent_run_id = run.parent_run?.id;\n            child_runs = [];\n        }\n        const persistedRun = {\n            id: run.id,\n            name: run.name,\n            start_time: run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order\n        };\n        return persistedRun;\n    }\n    async postRun(excludeChildRuns = true) {\n        const runCreate = await this._convertToCreate(this, true);\n        await this.client.createRun(runCreate);\n        if (!excludeChildRuns) {\n            warnOnce(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n            for (const childRun of this.child_runs){\n                await childRun.postRun(false);\n            }\n        }\n    }\n    async patchRun() {\n        const runUpdate = {\n            end_time: this.end_time,\n            error: this.error,\n            outputs: this.outputs,\n            parent_run_id: this.parent_run?.id,\n            reference_example_id: this.reference_example_id,\n            extra: this.extra,\n            events: this.events,\n            dotted_order: this.dotted_order,\n            trace_id: this.trace_id\n        };\n        await this.client.updateRun(this.id, runUpdate);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZCO0FBQ2tEO0FBQzFDO0FBQ3JDLE1BQU1JLGlCQUFpQixDQUFDO0FBQ3hCLFNBQVNDLFNBQVNDLE9BQU87SUFDckIsSUFBSSxDQUFDRixjQUFjLENBQUNFLFFBQVEsRUFBRTtRQUMxQkMsUUFBUUMsSUFBSSxDQUFDRjtRQUNiRixjQUFjLENBQUNFLFFBQVEsR0FBRztJQUM5QjtBQUNKO0FBQ0EsU0FBU0cscUJBQXFCQyxLQUFLO0lBQy9CLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQyxVQUFVO0FBQ25DO0FBQ08sU0FBU0MsMkJBQTJCQyxLQUFLLEVBQUVDLEtBQUs7SUFDbkQsT0FBUUwscUJBQXFCLENBQUMsRUFBRSxJQUFJTSxLQUFLRixPQUFPRyxXQUFXLEdBQUdDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsSUFDNUVIO0FBQ1I7QUFDTyxNQUFNSTtJQUNUQyxZQUFZQyxNQUFNLENBQUU7UUFDaEJDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsTUFBTTtZQUM5QkMsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWTtZQUNwQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCO1lBQ3hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxj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SUFBSSxFQUFFO1FBQ3BELE1BQU0sSUFBSSxDQUFDVCxNQUFNLENBQUM4QixTQUFTLENBQUNEO1FBQzVCLElBQUksQ0FBQ2xCLGtCQUFrQjtZQUNuQnJELFNBQVM7WUFDVCxLQUFLLE1BQU15RSxZQUFZLElBQUksQ0FBQ3ZDLFVBQVUsQ0FBRTtnQkFDcEMsTUFBTXVDLFNBQVNILE9BQU8sQ0FBQztZQUMzQjtRQUNKO0lBQ0o7SUFDQSxNQUFNSSxXQUFXO1FBQ2IsTUFBTUMsWUFBWTtZQUNkekIsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJGLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCRCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQmEsZUFBZSxJQUFJLENBQUNsQyxVQUFVLEVBQUVDO1lBQ2hDeUMsc0JBQXNCLElBQUksQ0FBQ0Esb0JBQW9CO1lBQy9DM0IsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJtQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQmhELGNBQWMsSUFBSSxDQUFDQSxZQUFZO1lBQy9CSCxVQUFVLElBQUksQ0FBQ0EsUUFBUTtRQUMzQjtRQUNBLE1BQU0sSUFBSSxDQUFDaUIsTUFBTSxDQUFDbUMsU0FBUyxDQUFDLElBQUksQ0FBQ2xELEVBQUUsRUFBRWdEO0lBQ3pDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWlsbC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9ydW5fdHJlZXMuanM/NTEyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuY29uc3Qgd2FybmVkTWVzc2FnZXMgPSB7fTtcbmZ1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXdhcm5lZE1lc3NhZ2VzW21lc3NhZ2VdKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgd2FybmVkTWVzc2FnZXNbbWVzc2FnZV0gPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmlwTm9uQWxwaGFudW1lcmljKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1stOi5dL2csIFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KGVwb2NoLCBydW5JZCkge1xuICAgIHJldHVybiAoc3RyaXBOb25BbHBoYW51bWVyaWMoYCR7bmV3IERhdGUoZXBvY2gpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgLTEpfTAwMFpgKSArXG4gICAgICAgIHJ1bklkKTtcbn1cbmV4cG9ydCBjbGFzcyBSdW5UcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5fdHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0X25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50X3J1blwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZF9ydW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXJ0X3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kX3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXh0cmFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VyaWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZlcmVuY2VfZXhhbXBsZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNlX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvdHRlZF9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gUnVuVHJlZS5nZXREZWZhdWx0Q29uZmlnKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyAuLi5kZWZhdWx0Q29uZmlnLCAuLi5jb25maWcgfSk7XG4gICAgICAgIGlmICghdGhpcy50cmFjZV9pZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLnBhcmVudF9ydW4udHJhY2VfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlX2lkID0gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RG90dGVkT3JkZXIgPSBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdCh0aGlzLnN0YXJ0X3RpbWUsIHRoaXMuaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG90dGVkX29yZGVyID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcnVuLmRvdHRlZF9vcmRlciArIFwiLlwiICsgY3VycmVudERvdHRlZE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPSBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdXVpZC52NCgpLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpID8/XG4gICAgICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpID8/IC8vIFRPRE86IERlcHJlY2F0ZVxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBhcGlfdXJsOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0VORFBPSU5UXCIpID8/IFwiaHR0cDovL2xvY2FsaG9zdDoxOTg0XCIsXG4gICAgICAgICAgICBhcGlfa2V5OiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIiksXG4gICAgICAgICAgICBjYWxsZXJfb3B0aW9uczoge30sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgc2VyaWFsaXplZDoge30sXG4gICAgICAgICAgICBpbnB1dHM6IHt9LFxuICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICAgICAgY2xpZW50OiBuZXcgQ2xpZW50KHt9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ2hpbGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogdGhpcyxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogdGhpcy5wcm9qZWN0X25hbWUsXG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZF9ydW5zLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGFzeW5jIGVuZChvdXRwdXRzLCBlcnJvciwgZW5kVGltZSA9IERhdGUubm93KCkpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmVuZF90aW1lID0gZW5kVGltZTtcbiAgICB9XG4gICAgYXN5bmMgX2NvbnZlcnRUb0NyZWF0ZShydW4sIGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJ1bkV4dHJhID0gcnVuLmV4dHJhID8/IHt9O1xuICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWUpIHtcbiAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW50aW1lRW52ID0gYXdhaXQgZ2V0UnVudGltZUVudmlyb25tZW50KCk7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bnRpbWVFbnYpKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWVba10pIHtcbiAgICAgICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRfcnVucztcbiAgICAgICAgbGV0IHBhcmVudF9ydW5faWQ7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IGF3YWl0IFByb21pc2UuYWxsKHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUoY2hpbGRfcnVuLCBleGNsdWRlQ2hpbGRSdW5zKSkpO1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQgPSBydW4ucGFyZW50X3J1bj8uaWQ7XG4gICAgICAgICAgICBjaGlsZF9ydW5zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVyc2lzdGVkUnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiBydW4ucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICBleHRyYTogcnVuRXh0cmEsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBydW4uc2VyaWFsaXplZCxcbiAgICAgICAgICAgIGVycm9yOiBydW4uZXJyb3IsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcnVuLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IGNoaWxkX3J1bnMsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRfcnVuX2lkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHJ1bi50cmFjZV9pZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcnVuLmRvdHRlZF9vcmRlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBlcnNpc3RlZFJ1bjtcbiAgICB9XG4gICAgYXN5bmMgcG9zdFJ1bihleGNsdWRlQ2hpbGRSdW5zID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBydW5DcmVhdGUgPSBhd2FpdCB0aGlzLl9jb252ZXJ0VG9DcmVhdGUodGhpcywgdHJ1ZSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUpO1xuICAgICAgICBpZiAoIWV4Y2x1ZGVDaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFwiUG9zdGluZyB3aXRoIGV4Y2x1ZGVDaGlsZFJ1bnM9ZmFsc2UgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiB0aGlzLmNoaWxkX3J1bnMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjaGlsZFJ1bi5wb3N0UnVuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXRjaFJ1bigpIHtcbiAgICAgICAgY29uc3QgcnVuVXBkYXRlID0ge1xuICAgICAgICAgICAgZW5kX3RpbWU6IHRoaXMuZW5kX3RpbWUsXG4gICAgICAgICAgICBlcnJvcjogdGhpcy5lcnJvcixcbiAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cyxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHRoaXMucGFyZW50X3J1bj8uaWQsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogdGhpcy5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgIGV4dHJhOiB0aGlzLmV4dHJhLFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cyxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogdGhpcy5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICB0cmFjZV9pZDogdGhpcy50cmFjZV9pZCxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQudXBkYXRlUnVuKHRoaXMuaWQsIHJ1blVwZGF0ZSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInV1aWQiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0UnVudGltZUVudmlyb25tZW50IiwiQ2xpZW50Iiwid2FybmVkTWVzc2FnZXMiLCJ3YXJuT25jZSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsInN0cmlwTm9uQWxwaGFudW1lcmljIiwiaW5wdXQiLCJyZXBsYWNlIiwiY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQiLCJlcG9jaCIsInJ1bklkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2xpY2UiLCJSdW5UcmVlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiZGVmYXVsdENvbmZpZyIsImdldERlZmF1bHRDb25maWciLCJhc3NpZ24iLCJ0cmFjZV9pZCIsInBhcmVudF9ydW4iLCJpZCIsImRvdHRlZF9vcmRlciIsImN1cnJlbnREb3R0ZWRPcmRlciIsInN0YXJ0X3RpbWUiLCJ2NCIsInJ1bl90eXBlIiwicHJvamVjdF9uYW1lIiwiY2hpbGRfcnVucyIsImFwaV91cmwiLCJhcGlfa2V5IiwiY2FsbGVyX29wdGlvbnMiLCJub3ciLCJzZXJpYWxpemVkIiwiaW5wdXRzIiwiZXh0cmEiLCJjbGllbnQiLCJjcmVhdGVDaGlsZCIsImNoaWxkIiwicHVzaCIsImVuZCIsIm91dHB1dHMiLCJlcnJvciIsImVuZFRpbWUiLCJlbmRfdGltZSIsIl9jb252ZXJ0VG9DcmVhdGUiLCJydW4iLCJleGNsdWRlQ2hpbGRSdW5zIiwicnVuRXh0cmEiLCJydW50aW1lIiwicnVudGltZUVudiIsImsiLCJ2IiwiZW50cmllcyIsInBhcmVudF9ydW5faWQiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiY2hpbGRfcnVuIiwidW5kZWZpbmVkIiwicGVyc2lzdGVkUnVuIiwibmFtZSIsInJlZmVyZW5jZV9leGFtcGxlX2lkIiwic2Vzc2lvbl9uYW1lIiwicG9zdFJ1biIsInJ1bkNyZWF0ZSIsImNyZWF0ZVJ1biIsImNoaWxkUnVuIiwicGF0Y2hSdW4iLCJydW5VcGRhdGUiLCJldmVudHMiLCJ1cGRhdGVSdW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408\n];\nconst STATUS_IGNORE = [\n    409\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */ class AsyncCaller {\n    constructor(params){\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_1__;\n        this.queue = new PQueue({\n            concurrency: this.maxConcurrency\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.queue.add(()=>p_retry__WEBPACK_IMPORTED_MODULE_0__(()=>callable(...args).catch((error)=>{\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (error instanceof Error) {\n                        throw error;\n                    } else {\n                        throw new Error(error);\n                    }\n                }), {\n                onFailedAttempt (error) {\n                    if (error.message.startsWith(\"Cancel\") || error.message.startsWith(\"TimeoutError\") || error.message.startsWith(\"AbortError\")) {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    if (error?.code === \"ECONNABORTED\") {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const status = error?.response?.status;\n                    if (status) {\n                        if (STATUS_NO_RETRY.includes(+status)) {\n                            throw error;\n                        } else if (STATUS_IGNORE.includes(+status)) {\n                            return;\n                        }\n                    }\n                },\n                // If needed we can change some of the defaults here,\n                // but they're quite sensible.\n                retries: this.maxRetries,\n                randomize: true\n            }), {\n            throwOnTimeout: true\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject)=>{\n                    options.signal?.addEventListener(\"abort\", ()=>{\n                        reject(new Error(\"AbortError\"));\n                    });\n                })\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(()=>fetch(...args).then((res)=>res.ok ? res : Promise.reject(res)));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUNHO0FBQ2hDLE1BQU1FLGtCQUFrQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxnQkFBZ0I7SUFDbEI7Q0FDSDtBQUNEOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1DO0lBQ1RDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQkMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxrQkFBa0I7WUFDMUNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ0MsY0FBYyxHQUFHUCxPQUFPTyxjQUFjLElBQUlDO1FBQy9DLElBQUksQ0FBQ0MsVUFBVSxHQUFHVCxPQUFPUyxVQUFVLElBQUk7UUFDdkMsTUFBTUMsU0FBUyxLQUFzQmYsR0FBR0EsK0NBQWlCLEdBQUdBLG9DQUFTQTtRQUNyRSxJQUFJLENBQUNpQixLQUFLLEdBQUcsSUFBSUYsT0FBTztZQUFFRyxhQUFhLElBQUksQ0FBQ04sY0FBYztRQUFDO0lBQy9EO0lBQ0EsOERBQThEO0lBQzlETyxLQUFLQyxRQUFRLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDSixLQUFLLENBQUNLLEdBQUcsQ0FBQyxJQUFNdkIsb0NBQU1BLENBQUMsSUFBTXFCLFlBQVlDLE1BQU1FLEtBQUssQ0FBQyxDQUFDQztvQkFDOUQsdURBQXVEO29CQUN2RCxJQUFJQSxpQkFBaUJDLE9BQU87d0JBQ3hCLE1BQU1EO29CQUNWLE9BQ0s7d0JBQ0QsTUFBTSxJQUFJQyxNQUFNRDtvQkFDcEI7Z0JBQ0osSUFBSTtnQkFDQUUsaUJBQWdCRixLQUFLO29CQUNqQixJQUFJQSxNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxhQUN6QkosTUFBTUcsT0FBTyxDQUFDQyxVQUFVLENBQUMsbUJBQ3pCSixNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxlQUFlO3dCQUN4QyxNQUFNSjtvQkFDVjtvQkFDQSw4REFBOEQ7b0JBQzlELElBQUlBLE9BQU9LLFNBQVMsZ0JBQWdCO3dCQUNoQyxNQUFNTDtvQkFDVjtvQkFDQSw4REFBOEQ7b0JBQzlELE1BQU1NLFNBQVNOLE9BQU9PLFVBQVVEO29CQUNoQyxJQUFJQSxRQUFRO3dCQUNSLElBQUk3QixnQkFBZ0IrQixRQUFRLENBQUMsQ0FBQ0YsU0FBUzs0QkFDbkMsTUFBTU47d0JBQ1YsT0FDSyxJQUFJdEIsY0FBYzhCLFFBQVEsQ0FBQyxDQUFDRixTQUFTOzRCQUN0Qzt3QkFDSjtvQkFDSjtnQkFDSjtnQkFDQSxxREFBcUQ7Z0JBQ3JELDhCQUE4QjtnQkFDOUJHLFNBQVMsSUFBSSxDQUFDbkIsVUFBVTtnQkFDeEJvQixXQUFXO1lBQ2YsSUFBSTtZQUFFQyxnQkFBZ0I7UUFBSztJQUMvQjtJQUNBLDhEQUE4RDtJQUM5REMsZ0JBQWdCQyxPQUFPLEVBQUVqQixRQUFRLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3hDLG1EQUFtRDtRQUNuRCx3RUFBd0U7UUFDeEUsSUFBSWdCLFFBQVFDLE1BQU0sRUFBRTtZQUNoQixPQUFPQyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2hCLElBQUksQ0FBQ3JCLElBQUksQ0FBQ0MsYUFBYUM7Z0JBQ3ZCLElBQUlrQixRQUFRLENBQUNFLEdBQUdDO29CQUNaTCxRQUFRQyxNQUFNLEVBQUVLLGlCQUFpQixTQUFTO3dCQUN0Q0QsT0FBTyxJQUFJakIsTUFBTTtvQkFDckI7Z0JBQ0o7YUFDSDtRQUNMO1FBQ0EsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ0MsYUFBYUM7SUFDbEM7SUFDQXVCLE1BQU0sR0FBR3ZCLElBQUksRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDRixJQUFJLENBQUMsSUFBTXlCLFNBQVN2QixNQUFNd0IsSUFBSSxDQUFDLENBQUNDLE1BQVNBLElBQUlDLEVBQUUsR0FBR0QsTUFBTVAsUUFBUUcsTUFBTSxDQUFDSTtJQUN2RjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVpbGwvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzP2E4ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCxcbiAgICA0MDEsXG4gICAgNDAzLFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDA2LFxuICAgIDQwNyxcbiAgICA0MDgsIC8vIFJlcXVlc3QgVGltZW91dFxuXTtcbmNvbnN0IFNUQVRVU19JR05PUkUgPSBbXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kID8gUFF1ZXVlTW9kLmRlZmF1bHQgOiBQUXVldWVNb2Q7XG4gICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlKHsgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3kgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbChjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5hZGQoKCkgPT4gcFJldHJ5KCgpID0+IGNhbGxhYmxlKC4uLmFyZ3MpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2FuY2VsXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlRpbWVvdXRFcnJvclwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJBYm9ydEVycm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGlmIChlcnJvcj8uY29kZSA9PT0gXCJFQ09OTkFCT1JURURcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvcj8ucmVzcG9uc2U/LnN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNUQVRVU19JR05PUkUuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gZmV0Y2goLi4uYXJncykudGhlbigocmVzKSA9PiAocmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsicFJldHJ5IiwiUFF1ZXVlTW9kIiwiU1RBVFVTX05PX1JFVFJZIiwiU1RBVFVTX0lHTk9SRSIsIkFzeW5jQ2FsbGVyIiwiY29uc3RydWN0b3IiLCJwYXJhbXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwibWF4Q29uY3VycmVuY3kiLCJJbmZpbml0eSIsIm1heFJldHJpZXMiLCJQUXVldWUiLCJkZWZhdWx0IiwicXVldWUiLCJjb25jdXJyZW5jeSIsImNhbGwiLCJjYWxsYWJsZSIsImFyZ3MiLCJhZGQiLCJjYXRjaCIsImVycm9yIiwiRXJyb3IiLCJvbkZhaWxlZEF0dGVtcHQiLCJtZXNzYWdlIiwic3RhcnRzV2l0aCIsImNvZGUiLCJzdGF0dXMiLCJyZXNwb25zZSIsImluY2x1ZGVzIiwicmV0cmllcyIsInJhbmRvbWl6ZSIsInRocm93T25UaW1lb3V0IiwiY2FsbFdpdGhPcHRpb25zIiwib3B0aW9ucyIsInNpZ25hbCIsIlByb21pc2UiLCJyYWNlIiwiXyIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmZXRjaCIsInRoZW4iLCJyZXMiLCJvayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),\n/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),\n/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = ()=> false && 0;\nconst isWebWorker = ()=>typeof globalThis === \"object\" && globalThis.constructor && globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = ()=> false || typeof navigator !== \"undefined\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = ()=>typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = ()=>typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\" && !isDeno();\nconst getEnv = ()=>{\n    if (globalEnv) {\n        return globalEnv;\n    }\n    if (isBrowser()) {\n        globalEnv = \"browser\";\n    } else if (isNode()) {\n        globalEnv = \"node\";\n    } else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    } else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    } else if (isDeno()) {\n        globalEnv = \"deno\";\n    } else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nasync function getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangChain-specific environment variables from the current runtime environment.\n * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific environment variables.\n */ function getLangChainEnvVars() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n            envVars[key] = value;\n        }\n    }\n    for(const key in envVars){\n        if ((key.toLowerCase().includes(\"key\") || key.toLowerCase().includes(\"secret\") || key.toLowerCase().includes(\"token\")) && typeof envVars[key] === \"string\") {\n            const value = envVars[key];\n            envVars[key] = value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the LangChain-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific metadata environment variables.\n */ function getLangChainEnvVarsMetadata() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\"\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\" && !excluded.includes(key) && !key.toLowerCase().includes(\"key\") && !key.toLowerCase().includes(\"secret\") && !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            } else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the environment variables from the current runtime environment.\n *\n * This function is designed to operate in a variety of JS environments,\n * including Node.js, Deno, browsers, etc.\n *\n * @returns {Record<string, string> | undefined}\n *  - A record of environment variables if available.\n *  - `undefined` if the environment does not support or allows access to environment variables.\n */ function getEnvironmentVariables() {\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            return Object.entries(process.env).reduce((acc, [key, value])=>{\n                acc[key] = String(value);\n                return acc;\n            }, {});\n        }\n        // For browsers and other environments, we may not have direct access to env variables\n        // Return undefined or any other fallback as required.\n        return undefined;\n    } catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n        return undefined;\n    }\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\" ? process.env?.[name] : undefined;\n    } catch (e) {\n        return undefined;\n    }\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */ function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\"\n    ];\n    const shas = {};\n    for (const env of common_release_envs){\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQ25CO0FBQzFDLElBQUlDO0FBQ0csTUFBTUMsWUFBWSxJQUFNLE1BQTZCLElBQUksQ0FBc0MsQ0FBQztBQUNoRyxNQUFNRyxjQUFjLElBQU0sT0FBT0MsZUFBZSxZQUNuREEsV0FBV0MsV0FBVyxJQUN0QkQsV0FBV0MsV0FBVyxDQUFDQyxJQUFJLEtBQUssNkJBQTZCO0FBQzFELE1BQU1DLFVBQVUsSUFBTSxNQUEwRCxJQUNsRixPQUFPQyxjQUFjLGVBQ2pCQSxDQUFBQSxVQUFVQyxTQUFTLENBQUNDLFFBQVEsQ0FBQyxjQUMxQkYsVUFBVUMsU0FBUyxDQUFDQyxRQUFRLENBQUMsUUFBTyxFQUFJO0FBQ3BELHlEQUF5RDtBQUN6RCw2QkFBNkI7QUFDdEIsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFNBQVMsWUFBWTtBQUN4RCxnREFBZ0Q7QUFDekMsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFlBQVksZUFDM0MsT0FBT0EsUUFBUUMsUUFBUSxLQUFLLGVBQzVCLE9BQU9ELFFBQVFDLFFBQVEsQ0FBQ0MsSUFBSSxLQUFLLGVBQ2pDLENBQUNMLFNBQVM7QUFDUCxNQUFNTSxTQUFTO0lBQ2xCLElBQUlsQixXQUFXO1FBQ1gsT0FBT0E7SUFDWDtJQUNBLElBQUlDLGFBQWE7UUFDYkQsWUFBWTtJQUNoQixPQUNLLElBQUljLFVBQVU7UUFDZmQsWUFBWTtJQUNoQixPQUNLLElBQUlJLGVBQWU7UUFDcEJKLFlBQVk7SUFDaEIsT0FDSyxJQUFJUSxXQUFXO1FBQ2hCUixZQUFZO0lBQ2hCLE9BQ0ssSUFBSVksVUFBVTtRQUNmWixZQUFZO0lBQ2hCLE9BQ0s7UUFDREEsWUFBWTtJQUNoQjtJQUNBLE9BQU9BO0FBQ1gsRUFBRTtBQUNGLElBQUltQjtBQUNHLGVBQWVDO0lBQ2xCLElBQUlELHVCQUF1QkUsV0FBVztRQUNs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NEIsdUJBQXVCMUMsSUFBSSxFQUFFMkIsS0FBSztJQUM5QyxJQUFJLE9BQU9uQixZQUFZLGFBQWE7UUFDaEMsMENBQTBDO1FBQzFDQSxRQUFRTyxHQUFHLENBQUNmLEtBQUssR0FBRzJCO0lBQ3hCO0FBQ0o7QUFDQSxJQUFJZ0I7QUFDSjs7OztDQUlDLEdBQ00sU0FBUzFCO0lBQ1osSUFBSTBCLHFCQUFxQjdCLFdBQVc7UUFDaEMsT0FBTzZCO0lBQ1g7SUFDQSxNQUFNQyxzQkFBc0I7UUFDeEI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU1DLE9BQU8sQ0FBQztJQUNkLEtBQUssTUFBTTlCLE9BQU82QixvQkFBcUI7UUFDbkMsTUFBTUUsU0FBU0wsdUJBQXVCMUI7UUFDdEMsSUFBSStCLFdBQVdoQyxXQUFXO1lBQ3RCK0IsSUFBSSxDQUFDOUIsSUFBSSxHQUFHK0I7UUFDaEI7SUFDSjtJQUNBSCxtQkFBbUJFO0lBQ25CLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWlsbC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9lbnYuanM/YTc0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmxpbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZsZXhkaW5lc2gvYnJvd3Nlci1vci1ub2RlXG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuLi9pbmRleC5qc1wiO1xubGV0IGdsb2JhbEVudjtcbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJOb2RlLmpzXCIpIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIikpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBpZiAoZ2xvYmFsRW52KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxFbnY7XG4gICAgfVxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxFbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSB7XG4gICAgaWYgKHJ1bnRpbWVFbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGdldEVudigpO1xuICAgICAgICBjb25zdCByZWxlYXNlRW52ID0gZ2V0U2hhcygpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdzbWl0aFwiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICAgICAgc2RrOiBcImxhbmdzbWl0aC1qc1wiLFxuICAgICAgICAgICAgc2RrX3ZlcnNpb246IF9fdmVyc2lvbl9fLFxuICAgICAgICAgICAgLi4ucmVsZWFzZUVudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bnRpbWVFbnZpcm9ubWVudDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIFNlbnNpdGl2ZSBrZXlzIChjb250YWluaW5nIHRoZSB3b3JkIFwia2V5XCIsIFwidG9rZW5cIiwgb3IgXCJzZWNyZXRcIikgaGF2ZSB0aGVpciB2YWx1ZXMgcmVkYWN0ZWQgZm9yIHNlY3VyaXR5LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnMoKSB7XG4gICAgY29uc3QgYWxsRW52VmFycyA9IGdldEVudmlyb25tZW50VmFyaWFibGVzKCkgfHwge307XG4gICAgY29uc3QgZW52VmFycyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFsbEVudlZhcnMpKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBlbnZWYXJzKSB7XG4gICAgICAgIGlmICgoa2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikgfHxcbiAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2VjcmV0XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSAmJlxuICAgICAgICAgICAgdHlwZW9mIGVudlZhcnNba2V5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbnZWYXJzW2tleV07XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPVxuICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDIpICsgXCIqXCIucmVwZWF0KHZhbHVlLmxlbmd0aCAtIDQpICsgdmFsdWUuc2xpY2UoLTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnZWYXJzO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIExhbmdDaGFpbi1zcGVjaWZpYyBtZXRhZGF0YSBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiAgLSBBIHJlY29yZCBvZiBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBjb25zdCBleGNsdWRlZCA9IFtcbiAgICAgICAgXCJMQU5HQ0hBSU5fQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fU0VTU0lPTlwiLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwiTEFOR0NIQUlOX1wiKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhZXhjbHVkZWQuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkxBTkdDSEFJTl9SRVZJU0lPTl9JRFwiKSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1tcInJldmlzaW9uX2lkXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gb3BlcmF0ZSBpbiBhIHZhcmlldHkgb2YgSlMgZW52aXJvbm1lbnRzLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGJyb3dzZXJzLCBldGMuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9XG4gKiAgLSBBIHJlY29yZCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgYXZhaWxhYmxlLlxuICogIC0gYHVuZGVmaW5lZGAgaWYgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3IgYWxsb3dzIGFjY2VzcyB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBicm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBtYXkgbm90IGhhdmUgZGlyZWN0IGFjY2VzcyB0byBlbnYgdmFyaWFibGVzXG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgb3IgYW55IG90aGVyIGZhbGxiYWNrIGFzIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHRoYXQgbWlnaHQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9od2NoYXNlMTcvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEVudmlyb25tZW50VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIHByb2Nlc3MuZW52W25hbWVdID0gdmFsdWU7XG4gICAgfVxufVxubGV0IGNhY2hlZENvbW1pdFNIQXM7XG4vKipcbiAqIEdldCB0aGUgR2l0IGNvbW1pdCBTSEEgZnJvbSBjb21tb24gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiB1c2VkIGJ5IGRpZmZlcmVudCBDSS9DRCBwbGF0Zm9ybXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgR2l0IGNvbW1pdCBTSEEgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXMoKSB7XG4gICAgaWYgKGNhY2hlZENvbW1pdFNIQXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQ29tbWl0U0hBcztcbiAgICB9XG4gICAgY29uc3QgY29tbW9uX3JlbGVhc2VfZW52cyA9IFtcbiAgICAgICAgXCJWRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJORVhUX1BVQkxJQ19WRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJDT01NSVRfUkVGXCIsXG4gICAgICAgIFwiUkVOREVSX0dJVF9DT01NSVRcIixcbiAgICAgICAgXCJDSV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ0lSQ0xFX1NIQTFcIixcbiAgICAgICAgXCJDRl9QQUdFU19DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiUkVBQ1RfQVBQX0dJVF9TSEFcIixcbiAgICAgICAgXCJTT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgICBcIkdJVEhVQl9TSEFcIixcbiAgICAgICAgXCJUUkFWSVNfQ09NTUlUXCIsXG4gICAgICAgIFwiR0lUX0NPTU1JVFwiLFxuICAgICAgICBcIkJVSUxEX1ZDU19OVU1CRVJcIixcbiAgICAgICAgXCJiYW1ib29fcGxhblJlcG9zaXRvcnlfcmV2aXNpb25cIixcbiAgICAgICAgXCJCdWlsZC5Tb3VyY2VWZXJzaW9uXCIsXG4gICAgICAgIFwiQklUQlVDS0VUX0NPTU1JVFwiLFxuICAgICAgICBcIkRST05FX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJTRU1BUEhPUkVfR0lUX1NIQVwiLFxuICAgICAgICBcIkJVSUxES0lURV9DT01NSVRcIixcbiAgICBdO1xuICAgIGNvbnN0IHNoYXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVudiBvZiBjb21tb25fcmVsZWFzZV9lbnZzKSB7XG4gICAgICAgIGNvbnN0IGVudlZhciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoZW52KTtcbiAgICAgICAgaWYgKGVudlZhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaGFzW2Vudl0gPSBlbnZWYXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FjaGVkQ29tbWl0U0hBcyA9IHNoYXM7XG4gICAgcmV0dXJuIHNoYXM7XG59XG4iXSwibmFtZXMiOlsiX192ZXJzaW9uX18iLCJnbG9iYWxFbnYiLCJpc0Jyb3dzZXIiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImlzV2ViV29ya2VyIiwiZ2xvYmFsVGhpcyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImlzSnNEb20iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsImlzRGVubyIsIkRlbm8iLCJpc05vZGUiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwiZ2V0RW52IiwicnVudGltZUVudmlyb25tZW50IiwiZ2V0UnVudGltZUVudmlyb25tZW50IiwidW5kZWZpbmVkIiwiZW52IiwicmVsZWFzZUVudiIsImdldFNoYXMiLCJsaWJyYXJ5IiwicnVudGltZSIsInNkayIsInNka192ZXJzaW9uIiwiZ2V0TGFuZ0NoYWluRW52VmFycyIsImFsbEVudlZhcnMiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyIsImVudlZhcnMiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJzdGFydHNXaXRoIiwidG9Mb3dlckNhc2UiLCJzbGljZSIsInJlcGVhdCIsImxlbmd0aCIsImdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSIsImV4Y2x1ZGVkIiwicmVkdWNlIiwiYWNjIiwiU3RyaW5nIiwiZSIsImdldEVudmlyb25tZW50VmFyaWFibGUiLCJzZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiY2FjaGVkQ29tbWl0U0hBcyIsImNvbW1vbl9yZWxlYXNlX2VudnMiLCJzaGFzIiwiZW52VmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(message) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: {\n            content: message.content\n        }\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = {\n            ...message.additional_kwargs\n        };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQkFBbUJDLE9BQU87SUFDdEMsT0FBTyxPQUFPQSxTQUFTQyxhQUFhO0FBQ3hDO0FBQ08sU0FBU0MsaUNBQWlDRixPQUFPO0lBQ3BELE1BQU1HLFlBQVk7UUFDZEMsTUFBTUosUUFBUUMsUUFBUTtRQUN0QkksTUFBTTtZQUFFQyxTQUFTTixRQUFRTSxPQUFPO1FBQUM7SUFDckM7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSU4sU0FBU08scUJBQ1RDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUU8saUJBQWlCLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ25EUCxVQUFVRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1lBQUUsR0FBR1AsUUFBUU8saUJBQWlCO1FBQUM7SUFDdEU7SUFDQSxPQUFPSjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVpbGwvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanM/NDczYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2U/Ll9nZXRUeXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUobWVzc2FnZSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IHtcbiAgICAgICAgdHlwZTogbWVzc2FnZS5fZ2V0VHlwZSgpLFxuICAgICAgICBkYXRhOiB7IGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9LFxuICAgIH07XG4gICAgLy8gQ2hlY2sgZm9yIHByZXNlbmNlIG9mIGtleXMgaW4gYWRkaXRpb25hbF9rd2FyZ3NcbiAgICBpZiAobWVzc2FnZT8uYWRkaXRpb25hbF9rd2FyZ3MgJiZcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb252ZXJ0ZWQuZGF0YS5hZGRpdGlvbmFsX2t3YXJncyA9IHsgLi4ubWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncyB9O1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuIl0sIm5hbWVzIjpbImlzTGFuZ0NoYWluTWVzc2FnZSIsIm1lc3NhZ2UiLCJfZ2V0VHlwZSIsImNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlIiwiY29udmVydGVkIiwidHlwZSIsImRhdGEiLCJjb250ZW50IiwiYWRkaXRpb25hbF9rd2FyZ3MiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWlsbC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvaW5kZXguanM/MTgxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Rpc3QvaW5kZXguanMnIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/index.js\n");

/***/ })

};
;