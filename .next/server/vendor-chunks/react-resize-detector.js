"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resize-detector";
exports.ids = ["vendor-chunks/react-resize-detector"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resize-detector/build/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-resize-detector/build/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, \"__esModule\", ({value:true}));var React=__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"),reactDom=__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"),debounce=__webpack_require__(/*! lodash/debounce */ \"(ssr)/./node_modules/lodash/debounce.js\"),throttle=__webpack_require__(/*! lodash/throttle */ \"(ssr)/./node_modules/lodash/throttle.js\");/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};var patchResizeCallback = function (resizeCallback, refreshMode, refreshRate, refreshOptions) {\n    switch (refreshMode) {\n        case 'debounce':\n            return debounce(resizeCallback, refreshRate, refreshOptions);\n        case 'throttle':\n            return throttle(resizeCallback, refreshRate, refreshOptions);\n        default:\n            return resizeCallback;\n    }\n};\nvar isFunction = function (fn) { return typeof fn === 'function'; };\nvar isSSR = function () { return typeof window === 'undefined'; };\nvar isDOMElement = function (element) {\n    return element instanceof Element || element instanceof HTMLDocument;\n};var ResizeDetector = /** @class */ (function (_super) {\n    __extends(ResizeDetector, _super);\n    function ResizeDetector(props) {\n        var _this = _super.call(this, props) || this;\n        _this.cancelHandler = function () {\n            if (_this.resizeHandler && _this.resizeHandler.cancel) {\n                // cancel debounced handler\n                _this.resizeHandler.cancel();\n                _this.resizeHandler = null;\n            }\n        };\n        _this.attachObserver = function () {\n            var _a = _this.props, targetRef = _a.targetRef, observerOptions = _a.observerOptions;\n            if (isSSR()) {\n                return;\n            }\n            if (targetRef && targetRef.current) {\n                _this.targetRef.current = targetRef.current;\n            }\n            var element = _this.getElement();\n            if (!element) {\n                // can't find element to observe\n                return;\n            }\n            if (_this.observableElement && _this.observableElement === element) {\n                // element is already observed\n                return;\n            }\n            _this.observableElement = element;\n            _this.resizeObserver.observe(element, observerOptions);\n        };\n        _this.getElement = function () {\n            var _a = _this.props, querySelector = _a.querySelector, targetDomEl = _a.targetDomEl;\n            if (isSSR())\n                return null;\n            // in case we pass a querySelector\n            if (querySelector)\n                return document.querySelector(querySelector);\n            // in case we pass a DOM element\n            if (targetDomEl && isDOMElement(targetDomEl))\n                return targetDomEl;\n            // in case we pass a React ref using React.createRef()\n            if (_this.targetRef && isDOMElement(_this.targetRef.current))\n                return _this.targetRef.current;\n            // the worse case when we don't receive any information from the parent and the library doesn't add any wrappers\n            // we have to use a deprecated `findDOMNode` method in order to find a DOM element to attach to\n            var currentElement = reactDom.findDOMNode(_this);\n            if (!currentElement)\n                return null;\n            var renderType = _this.getRenderType();\n            switch (renderType) {\n                case 'renderProp':\n                    return currentElement;\n                case 'childFunction':\n                    return currentElement;\n                case 'child':\n                    return currentElement;\n                case 'childArray':\n                    return currentElement;\n                default:\n                    return currentElement.parentElement;\n            }\n        };\n        _this.createResizeHandler = function (entries) {\n            var _a = _this.props, _b = _a.handleWidth, handleWidth = _b === void 0 ? true : _b, _c = _a.handleHeight, handleHeight = _c === void 0 ? true : _c, onResize = _a.onResize;\n            if (!handleWidth && !handleHeight)\n                return;\n            var notifyResize = function (_a) {\n                var width = _a.width, height = _a.height;\n                if (_this.state.width === width && _this.state.height === height) {\n                    // skip if dimensions haven't changed\n                    return;\n                }\n                if ((_this.state.width === width && !handleHeight) || (_this.state.height === height && !handleWidth)) {\n                    // process `handleHeight/handleWidth` props\n                    return;\n                }\n                onResize === null || onResize === void 0 ? void 0 : onResize(width, height);\n                _this.setState({ width: width, height: height });\n            };\n            entries.forEach(function (entry) {\n                var _a = (entry && entry.contentRect) || {}, width = _a.width, height = _a.height;\n                var shouldSetSize = !_this.skipOnMount && !isSSR();\n                if (shouldSetSize) {\n                    notifyResize({ width: width, height: height });\n                }\n                _this.skipOnMount = false;\n            });\n        };\n        _this.getRenderType = function () {\n            var _a = _this.props, render = _a.render, children = _a.children;\n            if (isFunction(render)) {\n                // DEPRECATED. Use `Child Function Pattern` instead\n                return 'renderProp';\n            }\n            if (isFunction(children)) {\n                return 'childFunction';\n            }\n            if (React.isValidElement(children)) {\n                return 'child';\n            }\n            if (Array.isArray(children)) {\n                // DEPRECATED. Wrap children with a single parent\n                return 'childArray';\n            }\n            // DEPRECATED. Use `Child Function Pattern` instead\n            return 'parent';\n        };\n        var skipOnMount = props.skipOnMount, refreshMode = props.refreshMode, _a = props.refreshRate, refreshRate = _a === void 0 ? 1000 : _a, refreshOptions = props.refreshOptions;\n        _this.state = {\n            width: undefined,\n            height: undefined\n        };\n        _this.sizeRef = {\n            current: _this.state\n        };\n        _this.skipOnMount = skipOnMount;\n        _this.targetRef = React.createRef();\n        _this.observableElement = null;\n        if (isSSR()) {\n            return _this;\n        }\n        _this.resizeHandler = patchResizeCallback(_this.createResizeHandler, refreshMode, refreshRate, refreshOptions);\n        _this.resizeObserver = new window.ResizeObserver(_this.resizeHandler);\n        return _this;\n    }\n    ResizeDetector.prototype.componentDidMount = function () {\n        this.attachObserver();\n    };\n    ResizeDetector.prototype.componentDidUpdate = function () {\n        this.attachObserver();\n        this.sizeRef.current = this.state;\n    };\n    ResizeDetector.prototype.componentWillUnmount = function () {\n        if (isSSR()) {\n            return;\n        }\n        this.observableElement = null;\n        this.resizeObserver.disconnect();\n        this.cancelHandler();\n    };\n    ResizeDetector.prototype.render = function () {\n        var _a = this.props, render = _a.render, children = _a.children, _b = _a.nodeType, WrapperTag = _b === void 0 ? 'div' : _b;\n        var _c = this.state, width = _c.width, height = _c.height;\n        var childProps = { width: width, height: height, targetRef: this.targetRef };\n        var renderType = this.getRenderType();\n        switch (renderType) {\n            case 'renderProp':\n                return render === null || render === void 0 ? void 0 : render(childProps);\n            case 'childFunction': {\n                var childFunction = children;\n                return childFunction === null || childFunction === void 0 ? void 0 : childFunction(childProps);\n            }\n            case 'child': {\n                // @TODO bug prone logic\n                var child = children;\n                if (child.type && typeof child.type === 'string') {\n                    // child is a native DOM elements such as div, span etc\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    childProps.targetRef; var nativeProps = __rest(childProps, [\"targetRef\"]);\n                    return React.cloneElement(child, nativeProps);\n                }\n                // class or functional component otherwise\n                return React.cloneElement(child, childProps);\n            }\n            case 'childArray': {\n                var childArray = children;\n                return childArray.map(function (el) { return !!el && React.cloneElement(el, childProps); });\n            }\n            default:\n                return React.createElement(WrapperTag, null);\n        }\n    };\n    return ResizeDetector;\n}(React.PureComponent));function withResizeDetector(ComponentInner, options) {\n    if (options === void 0) { options = {}; }\n    var ResizeDetectorHOC = /** @class */ (function (_super) {\n        __extends(ResizeDetectorHOC, _super);\n        function ResizeDetectorHOC() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.ref = React.createRef();\n            return _this;\n        }\n        ResizeDetectorHOC.prototype.render = function () {\n            var _a = this.props, forwardedRef = _a.forwardedRef, rest = __rest(_a, [\"forwardedRef\"]);\n            var targetRef = forwardedRef !== null && forwardedRef !== void 0 ? forwardedRef : this.ref;\n            return (React.createElement(ResizeDetector, __assign({}, options, { targetRef: targetRef }),\n                React.createElement(ComponentInner, __assign({ targetRef: targetRef }, rest))));\n        };\n        return ResizeDetectorHOC;\n    }(React.Component));\n    function forwardRefWrapper(props, ref) {\n        return React.createElement(ResizeDetectorHOC, __assign({}, props, { forwardedRef: ref }));\n    }\n    var name = ComponentInner.displayName || ComponentInner.name;\n    forwardRefWrapper.displayName = \"withResizeDetector(\".concat(name, \")\");\n    return React.forwardRef(forwardRefWrapper);\n}function useResizeDetector(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.skipOnMount, skipOnMount = _c === void 0 ? false : _c, refreshMode = _b.refreshMode, _d = _b.refreshRate, refreshRate = _d === void 0 ? 1000 : _d, refreshOptions = _b.refreshOptions, _e = _b.handleWidth, handleWidth = _e === void 0 ? true : _e, _f = _b.handleHeight, handleHeight = _f === void 0 ? true : _f, targetRef = _b.targetRef, observerOptions = _b.observerOptions, onResize = _b.onResize;\n    var skipResize = React.useRef(skipOnMount);\n    var _g = React.useState({\n        width: undefined,\n        height: undefined\n    }), size = _g[0], setSize = _g[1];\n    // we are going to use this ref to store the last element that was passed to the hook\n    var _h = React.useState((targetRef === null || targetRef === void 0 ? void 0 : targetRef.current) || null), refElement = _h[0], setRefElement = _h[1];\n    // if targetRef is passed, we need to update the refElement\n    // we have to use setTimeout because ref get assigned after the hook is called\n    // in the future releases we are going to remove targetRef and force users to use ref returned by the hook\n    if (targetRef) {\n        setTimeout(function () {\n            if (targetRef.current !== refElement) {\n                setRefElement(targetRef.current);\n            }\n        }, 0);\n    }\n    // this is a callback that will be called every time the ref is changed\n    // we call setState inside to trigger rerender\n    var onRefChange = React.useCallback(function (node) {\n        if (node !== refElement) {\n            setRefElement(node);\n        }\n    }, [refElement]);\n    // adding `current` to make it compatible with useRef shape\n    onRefChange.current = refElement;\n    var shouldSetSize = React.useCallback(function (prevSize, nextSize) {\n        if (prevSize.width === nextSize.width && prevSize.height === nextSize.height) {\n            // skip if dimensions haven't changed\n            return false;\n        }\n        if ((prevSize.width === nextSize.width && !handleHeight) ||\n            (prevSize.height === nextSize.height && !handleWidth)) {\n            // process `handleHeight/handleWidth` props\n            return false;\n        }\n        return true;\n    }, [handleWidth, handleHeight]);\n    var resizeCallback = React.useCallback(function (entries) {\n        if (!handleWidth && !handleHeight)\n            return;\n        if (skipResize.current) {\n            skipResize.current = false;\n            return;\n        }\n        entries.forEach(function (entry) {\n            var _a = (entry === null || entry === void 0 ? void 0 : entry.contentRect) || {}, width = _a.width, height = _a.height;\n            setSize(function (prevSize) {\n                if (!shouldSetSize(prevSize, { width: width, height: height }))\n                    return prevSize;\n                return { width: width, height: height };\n            });\n        });\n    }, [handleWidth, handleHeight, skipResize, shouldSetSize]);\n    var resizeHandler = React.useCallback(patchResizeCallback(resizeCallback, refreshMode, refreshRate, refreshOptions), [\n        resizeCallback,\n        refreshMode,\n        refreshRate,\n        refreshOptions\n    ]);\n    // on refElement change\n    React.useEffect(function () {\n        var resizeObserver;\n        if (refElement) {\n            resizeObserver = new window.ResizeObserver(resizeHandler);\n            resizeObserver.observe(refElement, observerOptions);\n        }\n        else {\n            if (size.width || size.height) {\n                setSize({ width: undefined, height: undefined });\n            }\n        }\n        return function () {\n            var _a, _b, _c;\n            (_a = resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect) === null || _a === void 0 ? void 0 : _a.call(resizeObserver);\n            (_c = (_b = resizeHandler).cancel) === null || _c === void 0 ? void 0 : _c.call(_b);\n        };\n    }, [resizeHandler, refElement]);\n    React.useEffect(function () {\n        onResize === null || onResize === void 0 ? void 0 : onResize(size.width, size.height);\n    }, [size]);\n    return __assign({ ref: onRefChange }, size);\n}exports[\"default\"]=ResizeDetector;exports.useResizeDetector=useResizeDetector;exports.withResizeDetector=withResizeDetector;//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXplLWRldGVjdG9yL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLFVBQVUsbUJBQU8sQ0FBQyx3R0FBTyxXQUFXLG1CQUFPLENBQUMsZ0hBQVcsV0FBVyxtQkFBTyxDQUFDLGdFQUFpQixXQUFXLG1CQUFPLENBQUMsZ0VBQWlCLEVBQUU7QUFDdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4QkFBOEI7QUFDL0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsbUNBQW1DLDhCQUE4QjtBQUNqRTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxvREFBb0Q7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWEsc0JBQXNCO0FBQ3RHLCtEQUErRCxzQkFBc0I7QUFDckY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlFQUFpRSxXQUFXLG1CQUFtQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBLCtDQUErQyw4QkFBOEI7QUFDN0U7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFDQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixrQkFBa0I7QUFDeEMsQ0FBQyxrQkFBZSxnQkFBZ0IseUJBQXlCLG1CQUFtQiwwQkFBMEIsb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVpbGwvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXplLWRldGVjdG9yL2J1aWxkL2luZGV4LmpzP2RjYTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdfX2VzTW9kdWxlJyx7dmFsdWU6dHJ1ZX0pO3ZhciBSZWFjdD1yZXF1aXJlKCdyZWFjdCcpLHJlYWN0RG9tPXJlcXVpcmUoJ3JlYWN0LWRvbScpLGRlYm91bmNlPXJlcXVpcmUoJ2xvZGFzaC9kZWJvdW5jZScpLHRocm90dGxlPXJlcXVpcmUoJ2xvZGFzaC90aHJvdHRsZScpOy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O3ZhciBwYXRjaFJlc2l6ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHJlc2l6ZUNhbGxiYWNrLCByZWZyZXNoTW9kZSwgcmVmcmVzaFJhdGUsIHJlZnJlc2hPcHRpb25zKSB7XG4gICAgc3dpdGNoIChyZWZyZXNoTW9kZSkge1xuICAgICAgICBjYXNlICdkZWJvdW5jZSc6XG4gICAgICAgICAgICByZXR1cm4gZGVib3VuY2UocmVzaXplQ2FsbGJhY2ssIHJlZnJlc2hSYXRlLCByZWZyZXNoT3B0aW9ucyk7XG4gICAgICAgIGNhc2UgJ3Rocm90dGxlJzpcbiAgICAgICAgICAgIHJldHVybiB0aHJvdHRsZShyZXNpemVDYWxsYmFjaywgcmVmcmVzaFJhdGUsIHJlZnJlc2hPcHRpb25zKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByZXNpemVDYWxsYmFjaztcbiAgICB9XG59O1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJzsgfTtcbnZhciBpc1NTUiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnOyB9O1xudmFyIGlzRE9NRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRG9jdW1lbnQ7XG59O3ZhciBSZXNpemVEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaXplRGV0ZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzaXplRGV0ZWN0b3IocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmVzaXplSGFuZGxlciAmJiBfdGhpcy5yZXNpemVIYW5kbGVyLmNhbmNlbCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBkZWJvdW5jZWQgaGFuZGxlclxuICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6ZUhhbmRsZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzaXplSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmF0dGFjaE9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIHRhcmdldFJlZiA9IF9hLnRhcmdldFJlZiwgb2JzZXJ2ZXJPcHRpb25zID0gX2Eub2JzZXJ2ZXJPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGlzU1NSKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0UmVmICYmIHRhcmdldFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGFyZ2V0UmVmLmN1cnJlbnQgPSB0YXJnZXRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuJ3QgZmluZCBlbGVtZW50IHRvIG9ic2VydmVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMub2JzZXJ2YWJsZUVsZW1lbnQgJiYgX3RoaXMub2JzZXJ2YWJsZUVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgb2JzZXJ2ZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZhYmxlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBfdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgcXVlcnlTZWxlY3RvciA9IF9hLnF1ZXJ5U2VsZWN0b3IsIHRhcmdldERvbUVsID0gX2EudGFyZ2V0RG9tRWw7XG4gICAgICAgICAgICBpZiAoaXNTU1IoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgcGFzcyBhIHF1ZXJ5U2VsZWN0b3JcbiAgICAgICAgICAgIGlmIChxdWVyeVNlbGVjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5U2VsZWN0b3IpO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBwYXNzIGEgRE9NIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICh0YXJnZXREb21FbCAmJiBpc0RPTUVsZW1lbnQodGFyZ2V0RG9tRWwpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXREb21FbDtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgcGFzcyBhIFJlYWN0IHJlZiB1c2luZyBSZWFjdC5jcmVhdGVSZWYoKVxuICAgICAgICAgICAgaWYgKF90aGlzLnRhcmdldFJlZiAmJiBpc0RPTUVsZW1lbnQoX3RoaXMudGFyZ2V0UmVmLmN1cnJlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50YXJnZXRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIC8vIHRoZSB3b3JzZSBjYXNlIHdoZW4gd2UgZG9uJ3QgcmVjZWl2ZSBhbnkgaW5mb3JtYXRpb24gZnJvbSB0aGUgcGFyZW50IGFuZCB0aGUgbGlicmFyeSBkb2Vzbid0IGFkZCBhbnkgd3JhcHBlcnNcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gdXNlIGEgZGVwcmVjYXRlZCBgZmluZERPTU5vZGVgIG1ldGhvZCBpbiBvcmRlciB0byBmaW5kIGEgRE9NIGVsZW1lbnQgdG8gYXR0YWNoIHRvXG4gICAgICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSByZWFjdERvbS5maW5kRE9NTm9kZShfdGhpcyk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHJlbmRlclR5cGUgPSBfdGhpcy5nZXRSZW5kZXJUeXBlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlbmRlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZW5kZXJQcm9wJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoaWxkRnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hpbGQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hpbGRBcnJheSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY3JlYXRlUmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgX2IgPSBfYS5oYW5kbGVXaWR0aCwgaGFuZGxlV2lkdGggPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IF9hLmhhbmRsZUhlaWdodCwgaGFuZGxlSGVpZ2h0ID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgb25SZXNpemUgPSBfYS5vblJlc2l6ZTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlV2lkdGggJiYgIWhhbmRsZUhlaWdodClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbm90aWZ5UmVzaXplID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUud2lkdGggPT09IHdpZHRoICYmIF90aGlzLnN0YXRlLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgZGltZW5zaW9ucyBoYXZlbid0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKF90aGlzLnN0YXRlLndpZHRoID09PSB3aWR0aCAmJiAhaGFuZGxlSGVpZ2h0KSB8fCAoX3RoaXMuc3RhdGUuaGVpZ2h0ID09PSBoZWlnaHQgJiYgIWhhbmRsZVdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGBoYW5kbGVIZWlnaHQvaGFuZGxlV2lkdGhgIHByb3BzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25SZXNpemUgPT09IG51bGwgfHwgb25SZXNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gKGVudHJ5ICYmIGVudHJ5LmNvbnRlbnRSZWN0KSB8fCB7fSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGRTZXRTaXplID0gIV90aGlzLnNraXBPbk1vdW50ICYmICFpc1NTUigpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTZXRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeVJlc2l6ZSh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnNraXBPbk1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0UmVuZGVyVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCByZW5kZXIgPSBfYS5yZW5kZXIsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihyZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gREVQUkVDQVRFRC4gVXNlIGBDaGlsZCBGdW5jdGlvbiBQYXR0ZXJuYCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZW5kZXJQcm9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnY2hpbGRGdW5jdGlvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjaGlsZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICAvLyBERVBSRUNBVEVELiBXcmFwIGNoaWxkcmVuIHdpdGggYSBzaW5nbGUgcGFyZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjaGlsZEFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQuIFVzZSBgQ2hpbGQgRnVuY3Rpb24gUGF0dGVybmAgaW5zdGVhZFxuICAgICAgICAgICAgcmV0dXJuICdwYXJlbnQnO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2tpcE9uTW91bnQgPSBwcm9wcy5za2lwT25Nb3VudCwgcmVmcmVzaE1vZGUgPSBwcm9wcy5yZWZyZXNoTW9kZSwgX2EgPSBwcm9wcy5yZWZyZXNoUmF0ZSwgcmVmcmVzaFJhdGUgPSBfYSA9PT0gdm9pZCAwID8gMTAwMCA6IF9hLCByZWZyZXNoT3B0aW9ucyA9IHByb3BzLnJlZnJlc2hPcHRpb25zO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoZWlnaHQ6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zaXplUmVmID0ge1xuICAgICAgICAgICAgY3VycmVudDogX3RoaXMuc3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2tpcE9uTW91bnQgPSBza2lwT25Nb3VudDtcbiAgICAgICAgX3RoaXMudGFyZ2V0UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLm9ic2VydmFibGVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzU1NSKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5yZXNpemVIYW5kbGVyID0gcGF0Y2hSZXNpemVDYWxsYmFjayhfdGhpcy5jcmVhdGVSZXNpemVIYW5kbGVyLCByZWZyZXNoTW9kZSwgcmVmcmVzaFJhdGUsIHJlZnJlc2hPcHRpb25zKTtcbiAgICAgICAgX3RoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgd2luZG93LlJlc2l6ZU9ic2VydmVyKF90aGlzLnJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc2l6ZURldGVjdG9yLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hPYnNlcnZlcigpO1xuICAgIH07XG4gICAgUmVzaXplRGV0ZWN0b3IucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hPYnNlcnZlcigpO1xuICAgICAgICB0aGlzLnNpemVSZWYuY3VycmVudCA9IHRoaXMuc3RhdGU7XG4gICAgfTtcbiAgICBSZXNpemVEZXRlY3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1NTUigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmNhbmNlbEhhbmRsZXIoKTtcbiAgICB9O1xuICAgIFJlc2l6ZURldGVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHJlbmRlciA9IF9hLnJlbmRlciwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgX2IgPSBfYS5ub2RlVHlwZSwgV3JhcHBlclRhZyA9IF9iID09PSB2b2lkIDAgPyAnZGl2JyA6IF9iO1xuICAgICAgICB2YXIgX2MgPSB0aGlzLnN0YXRlLCB3aWR0aCA9IF9jLndpZHRoLCBoZWlnaHQgPSBfYy5oZWlnaHQ7XG4gICAgICAgIHZhciBjaGlsZFByb3BzID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCB0YXJnZXRSZWY6IHRoaXMudGFyZ2V0UmVmIH07XG4gICAgICAgIHZhciByZW5kZXJUeXBlID0gdGhpcy5nZXRSZW5kZXJUeXBlKCk7XG4gICAgICAgIHN3aXRjaCAocmVuZGVyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncmVuZGVyUHJvcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlciA9PT0gbnVsbCB8fCByZW5kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcihjaGlsZFByb3BzKTtcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkRnVuY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkRnVuY3Rpb24gPSBjaGlsZHJlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRGdW5jdGlvbiA9PT0gbnVsbCB8fCBjaGlsZEZ1bmN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZEZ1bmN0aW9uKGNoaWxkUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY2hpbGQnOiB7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE8gYnVnIHByb25lIGxvZ2ljXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgJiYgdHlwZW9mIGNoaWxkLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoaWxkIGlzIGEgbmF0aXZlIERPTSBlbGVtZW50cyBzdWNoIGFzIGRpdiwgc3BhbiBldGNcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzLnRhcmdldFJlZjsgdmFyIG5hdGl2ZVByb3BzID0gX19yZXN0KGNoaWxkUHJvcHMsIFtcInRhcmdldFJlZlwiXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIG5hdGl2ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2xhc3Mgb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjaGlsZEFycmF5Jzoge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEFycmF5ID0gY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkQXJyYXkubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbCAmJiBSZWFjdC5jbG9uZUVsZW1lbnQoZWwsIGNoaWxkUHJvcHMpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlclRhZywgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXNpemVEZXRlY3Rvcjtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCkpO2Z1bmN0aW9uIHdpdGhSZXNpemVEZXRlY3RvcihDb21wb25lbnRJbm5lciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIFJlc2l6ZURldGVjdG9ySE9DID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmVzaXplRGV0ZWN0b3JIT0MsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZURldGVjdG9ySE9DKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5yZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBSZXNpemVEZXRlY3RvckhPQy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZm9yd2FyZGVkUmVmID0gX2EuZm9yd2FyZGVkUmVmLCByZXN0ID0gX19yZXN0KF9hLCBbXCJmb3J3YXJkZWRSZWZcIl0pO1xuICAgICAgICAgICAgdmFyIHRhcmdldFJlZiA9IGZvcndhcmRlZFJlZiAhPT0gbnVsbCAmJiBmb3J3YXJkZWRSZWYgIT09IHZvaWQgMCA/IGZvcndhcmRlZFJlZiA6IHRoaXMucmVmO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlc2l6ZURldGVjdG9yLCBfX2Fzc2lnbih7fSwgb3B0aW9ucywgeyB0YXJnZXRSZWY6IHRhcmdldFJlZiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudElubmVyLCBfX2Fzc2lnbih7IHRhcmdldFJlZjogdGFyZ2V0UmVmIH0sIHJlc3QpKSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVzaXplRGV0ZWN0b3JIT0M7XG4gICAgfShSZWFjdC5Db21wb25lbnQpKTtcbiAgICBmdW5jdGlvbiBmb3J3YXJkUmVmV3JhcHBlcihwcm9wcywgcmVmKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlc2l6ZURldGVjdG9ySE9DLCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgZm9yd2FyZGVkUmVmOiByZWYgfSkpO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IENvbXBvbmVudElubmVyLmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudElubmVyLm5hbWU7XG4gICAgZm9yd2FyZFJlZldyYXBwZXIuZGlzcGxheU5hbWUgPSBcIndpdGhSZXNpemVEZXRlY3RvcihcIi5jb25jYXQobmFtZSwgXCIpXCIpO1xuICAgIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKGZvcndhcmRSZWZXcmFwcGVyKTtcbn1mdW5jdGlvbiB1c2VSZXNpemVEZXRlY3RvcihfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnNraXBPbk1vdW50LCBza2lwT25Nb3VudCA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCByZWZyZXNoTW9kZSA9IF9iLnJlZnJlc2hNb2RlLCBfZCA9IF9iLnJlZnJlc2hSYXRlLCByZWZyZXNoUmF0ZSA9IF9kID09PSB2b2lkIDAgPyAxMDAwIDogX2QsIHJlZnJlc2hPcHRpb25zID0gX2IucmVmcmVzaE9wdGlvbnMsIF9lID0gX2IuaGFuZGxlV2lkdGgsIGhhbmRsZVdpZHRoID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZSwgX2YgPSBfYi5oYW5kbGVIZWlnaHQsIGhhbmRsZUhlaWdodCA9IF9mID09PSB2b2lkIDAgPyB0cnVlIDogX2YsIHRhcmdldFJlZiA9IF9iLnRhcmdldFJlZiwgb2JzZXJ2ZXJPcHRpb25zID0gX2Iub2JzZXJ2ZXJPcHRpb25zLCBvblJlc2l6ZSA9IF9iLm9uUmVzaXplO1xuICAgIHZhciBza2lwUmVzaXplID0gUmVhY3QudXNlUmVmKHNraXBPbk1vdW50KTtcbiAgICB2YXIgX2cgPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgIGhlaWdodDogdW5kZWZpbmVkXG4gICAgfSksIHNpemUgPSBfZ1swXSwgc2V0U2l6ZSA9IF9nWzFdO1xuICAgIC8vIHdlIGFyZSBnb2luZyB0byB1c2UgdGhpcyByZWYgdG8gc3RvcmUgdGhlIGxhc3QgZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIGhvb2tcbiAgICB2YXIgX2ggPSBSZWFjdC51c2VTdGF0ZSgodGFyZ2V0UmVmID09PSBudWxsIHx8IHRhcmdldFJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0UmVmLmN1cnJlbnQpIHx8IG51bGwpLCByZWZFbGVtZW50ID0gX2hbMF0sIHNldFJlZkVsZW1lbnQgPSBfaFsxXTtcbiAgICAvLyBpZiB0YXJnZXRSZWYgaXMgcGFzc2VkLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmVmRWxlbWVudFxuICAgIC8vIHdlIGhhdmUgdG8gdXNlIHNldFRpbWVvdXQgYmVjYXVzZSByZWYgZ2V0IGFzc2lnbmVkIGFmdGVyIHRoZSBob29rIGlzIGNhbGxlZFxuICAgIC8vIGluIHRoZSBmdXR1cmUgcmVsZWFzZXMgd2UgYXJlIGdvaW5nIHRvIHJlbW92ZSB0YXJnZXRSZWYgYW5kIGZvcmNlIHVzZXJzIHRvIHVzZSByZWYgcmV0dXJuZWQgYnkgdGhlIGhvb2tcbiAgICBpZiAodGFyZ2V0UmVmKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldFJlZi5jdXJyZW50ICE9PSByZWZFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmRWxlbWVudCh0YXJnZXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvLyB0aGlzIGlzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSByZWYgaXMgY2hhbmdlZFxuICAgIC8vIHdlIGNhbGwgc2V0U3RhdGUgaW5zaWRlIHRvIHRyaWdnZXIgcmVyZW5kZXJcbiAgICB2YXIgb25SZWZDaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAhPT0gcmVmRWxlbWVudCkge1xuICAgICAgICAgICAgc2V0UmVmRWxlbWVudChub2RlKTtcbiAgICAgICAgfVxuICAgIH0sIFtyZWZFbGVtZW50XSk7XG4gICAgLy8gYWRkaW5nIGBjdXJyZW50YCB0byBtYWtlIGl0IGNvbXBhdGlibGUgd2l0aCB1c2VSZWYgc2hhcGVcbiAgICBvblJlZkNoYW5nZS5jdXJyZW50ID0gcmVmRWxlbWVudDtcbiAgICB2YXIgc2hvdWxkU2V0U2l6ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwcmV2U2l6ZSwgbmV4dFNpemUpIHtcbiAgICAgICAgaWYgKHByZXZTaXplLndpZHRoID09PSBuZXh0U2l6ZS53aWR0aCAmJiBwcmV2U2l6ZS5oZWlnaHQgPT09IG5leHRTaXplLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc2tpcCBpZiBkaW1lbnNpb25zIGhhdmVuJ3QgY2hhbmdlZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJldlNpemUud2lkdGggPT09IG5leHRTaXplLndpZHRoICYmICFoYW5kbGVIZWlnaHQpIHx8XG4gICAgICAgICAgICAocHJldlNpemUuaGVpZ2h0ID09PSBuZXh0U2l6ZS5oZWlnaHQgJiYgIWhhbmRsZVdpZHRoKSkge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyBgaGFuZGxlSGVpZ2h0L2hhbmRsZVdpZHRoYCBwcm9wc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIFtoYW5kbGVXaWR0aCwgaGFuZGxlSGVpZ2h0XSk7XG4gICAgdmFyIHJlc2l6ZUNhbGxiYWNrID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgaWYgKCFoYW5kbGVXaWR0aCAmJiAhaGFuZGxlSGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoc2tpcFJlc2l6ZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBza2lwUmVzaXplLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSAoZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJ5LmNvbnRlbnRSZWN0KSB8fCB7fSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICAgICAgc2V0U2l6ZShmdW5jdGlvbiAocHJldlNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFNldFNpemUocHJldlNpemUsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZTaXplO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbaGFuZGxlV2lkdGgsIGhhbmRsZUhlaWdodCwgc2tpcFJlc2l6ZSwgc2hvdWxkU2V0U2l6ZV0pO1xuICAgIHZhciByZXNpemVIYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2socGF0Y2hSZXNpemVDYWxsYmFjayhyZXNpemVDYWxsYmFjaywgcmVmcmVzaE1vZGUsIHJlZnJlc2hSYXRlLCByZWZyZXNoT3B0aW9ucyksIFtcbiAgICAgICAgcmVzaXplQ2FsbGJhY2ssXG4gICAgICAgIHJlZnJlc2hNb2RlLFxuICAgICAgICByZWZyZXNoUmF0ZSxcbiAgICAgICAgcmVmcmVzaE9wdGlvbnNcbiAgICBdKTtcbiAgICAvLyBvbiByZWZFbGVtZW50IGNoYW5nZVxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXNpemVPYnNlcnZlcjtcbiAgICAgICAgaWYgKHJlZkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IHdpbmRvdy5SZXNpemVPYnNlcnZlcihyZXNpemVIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmRWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzaXplLndpZHRoIHx8IHNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc2V0U2l6ZSh7IHdpZHRoOiB1bmRlZmluZWQsIGhlaWdodDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIChfYSA9IHJlc2l6ZU9ic2VydmVyID09PSBudWxsIHx8IHJlc2l6ZU9ic2VydmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyZXNpemVPYnNlcnZlcik7XG4gICAgICAgICAgICAoX2MgPSAoX2IgPSByZXNpemVIYW5kbGVyKS5jYW5jZWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICAgICAgfTtcbiAgICB9LCBbcmVzaXplSGFuZGxlciwgcmVmRWxlbWVudF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uUmVzaXplID09PSBudWxsIHx8IG9uUmVzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblJlc2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgfSwgW3NpemVdKTtcbiAgICByZXR1cm4gX19hc3NpZ24oeyByZWY6IG9uUmVmQ2hhbmdlIH0sIHNpemUpO1xufWV4cG9ydHMuZGVmYXVsdD1SZXNpemVEZXRlY3RvcjtleHBvcnRzLnVzZVJlc2l6ZURldGVjdG9yPXVzZVJlc2l6ZURldGVjdG9yO2V4cG9ydHMud2l0aFJlc2l6ZURldGVjdG9yPXdpdGhSZXNpemVEZXRlY3RvcjsvLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resize-detector/build/index.js\n");

/***/ })

};
;